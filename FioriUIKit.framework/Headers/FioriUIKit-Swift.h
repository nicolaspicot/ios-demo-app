// Generated by Apple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import UIKit;
@import CoreGraphics;
@import AVFoundation;
@import Foundation;
@import ObjectiveC;
#endif

#import <FioriUIKit/FioriUIKit.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSCoder;

SWIFT_CLASS("_TtC10FioriUIKit13NibDesignable")
@interface NibDesignable : UIView
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  ActivityControl is a stand alone component supporting user activities. By default, it supports phone, email, message, videoCall.
  <h2>Code usage:</h2>
  \code
  //You can create your own activity object if you want.
  let myTwilioActivity = ActivityItem(icon: UIImage(named: "asset"), identifier: "mycustomer.twilio")
  let activities: [ActivityItem] = [ActivityItem.phone, ActivityItem.message, myTwilioActivity]

  //Create a ActivityControl object.
  let activityControl = ActivityControl()
  activityControl.addActivities(activities)
  activityControl.delegate = SomeClass()

  //Optionally, set an item size (if nil, intrinsic size of image will be used)
  activityControl.itemSize = CGSize(width: 44.0, height: 44.0)

  //Optionally, set a limit to visible items (useful for hiding items in `.compact` horizontal mode)
  activityControl.maxVisibleItems = 3

  //Optionally, set the inter-item spacing (useful for showing more items in `.compact` horizontal mode)
  activityControl.spacing = 29.0

  cell.contentView.addSubview(activityControl)
  activityControl.translatesAutoresizingMaskIntoConstraints = false
  activityControl.leadingAnchor.constraint(equalTo: (cell.contentView.layoutMarginsGuide.leadingAnchor)).isActive = true
  activityControl.topAnchor.constraint(equalTo: (cell.contentView.layoutMarginsGuide.topAnchor)).isActive = true
  activityControl.bottomAnchor.constraint(equalTo: (cell.contentView.layoutMarginsGuide.bottomAnchor)).isActive = true

  //Implement this method in your action handler class.
  func activityControl(_ activityControl: ActivityControl, didSelectActivity activityItem: ActivityItem) {
      switch activityItem {
          case ActivityItem.phone:
             //do something
          case ActivityItem.message:
             //do something
          case myTwilioActivity:
             //do something
          default:
             break
      }
  }

  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit15ActivityControl")
@interface ActivityControl : NibDesignable
@property (nonatomic) NSInteger maxVisibleItems;
/**
  Inter-item spacing between items in control.  Follows behavior of \code
  UIStackView.spacing
  \endcode property.  Defaults to 29.0.
*/
@property (nonatomic) CGFloat spacing;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC10FioriUIKit26NibDesignableTableViewCell")
@interface NibDesignableTableViewCell : UITableViewCell
/**
  :nodoc:
*/
@property (nonatomic, readonly, strong) UIView * _Nonnull nibContainerView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UICollectionView;
@class UICollectionViewCell;
@class UIImagePickerController;

/**
  The reusable UI component implemented as an UITableViewCell
  to manage selecting attachments. One can either use the camera to take a photo, or select a photo from the photo library.  The cell’s \code
  AttachmentFormCellDelegate
  \endcode should handle addition or deletion events.
  important:

  The cell’s parent \code
  UITableViewController
  \endcode must subclass \code
  FormTableViewController
  \endcode
  Use the default implementation of the \code
  AttachmentFormCellHandler: AttachmentFormCellDelegate
  \endcode, or provide a custom implementation for the delegate.
  \code

  let attachmentDelegate = AttachmentFormCellHandler()

  override func viewDidLoad() {
      super.viewDidLoad()
      self.tableView.register(AttachmentFormCell.self, forCellReuseIdentifier: AttachmentFormCell.reuseIdentifier)
      // ...
  }

  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      // ...
      let cell = tableView.dequeueReusableCell(withIdentifier: AttachmentFormCell.reuseIdentifier, for: indexPath) as! AttachmentFormCell
      cell.attachmentDelegate = attachmentDelegate
      return cell
      // ...
  }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit18AttachmentFormCell")
@interface AttachmentFormCell : NibDesignableTableViewCell <UICollectionViewDataSource, UICollectionViewDelegate, AVAudioRecorderDelegate, AVAudioPlayerDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate>
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  Set this property to customized the title for this attachments cell.
  If this property is not set, the default title will be displayed.
  The default title format is “Attachment (%d)” where %d will be the number of
  attachments already selected.
*/
@property (nonatomic, copy) NSString * _Nullable attachmentsTitleFormat;
/**
  String to be displayed in the action list title
  when “add attachment” button is tapped.
  If this is not set, the default title string is \code
  Add Attachment
  \endcode
  from the localized strings file \code
  FormCell.strings
  \endcode
*/
@property (nonatomic, copy) NSString * _Nullable addAttachmentTitleString;
/**
  The string for taking a photo in add attachment action list.
  If this is not set, the default string is \code
  Take Photo
  \endcode
  from the localized strings file \code
  FormCell.strings
  \endcode
*/
@property (nonatomic, copy) NSString * _Nullable takePhotoString;
/**
  The string for choosing a photo from photo library in
  add attachment action list.
  If this is not set, the default string is \code
  Photo Library
  \endcode
  from the localized strings file \code
  FormCell.strings
  \endcode
*/
@property (nonatomic, copy) NSString * _Nullable photoLibraryString;
/**
  The string for canceling adding an attachment in
  add attachment action list.
  If this is not set, the default string is \code
  Cancel
  \endcode
  from the localized strings file \code
  FormCell.strings
  \endcode
*/
@property (nonatomic, copy) NSString * _Nullable cancelString;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (NSInteger)collectionView:(UICollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section;
/**
  :nodoc:
*/
- (UICollectionViewCell * _Nonnull)collectionView:(UICollectionView * _Nonnull)collectionView cellForItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)collectionView:(UICollectionView * _Nonnull)collectionView didSelectItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)deleteAttachmentAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (void)didAddAttachmentTouchUpInside:(id _Nonnull)sender;
/**
  :nodoc:
*/
- (void)imagePickerController:(UIImagePickerController * _Nonnull)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *, id> * _Nonnull)info;
/**
  :nodoc:
*/
- (void)imagePickerControllerDidCancel:(UIImagePickerController * _Nonnull)picker;
/**
  Get the number of attachments in this cell.
  <ul>
    <li>
      returns The number of attachments in this cell.
    </li>
  </ul>
*/
- (NSInteger)attachmentCount;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end

@class UIImage;
@class UITraitCollection;
@class FioriImageView;
@class UILabel;

/**
  ContactCell is variant of UITableViewCell defined in FioriUIKit. It contains a UIImageView, serveral labels and a activityView component.
  Width of image is set to 35px and width of mainStackView is set to 30% of cell width by default.
  At most three buttons are supported in the cell.
  <h2>Code usage:</h2>
  \code
  //Developer needs to define MyContactObject and DataSource first.

  //Contact object mockup
  class MyContactObject {
     var name: String
     var title: String
     var address: String
     var image: UIImage
     init(name: String, title: String, address: String, image: UIImage) {
         self.name = name
         self.title = title
         self.address = address
         self.image = image
     }
     func call(){
         // dial the phone number
     }
     func sendMessage(){
         // locate assistant contact info & email
     }
  }


  \endcode\code

  //Create a ContactCell in a TableView
  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      let cell = tableView.dequeueReusableCell(withIdentifier: ContactCell.reuseIdentifier) as! ContactCell
      let activities: [ActivityItem] = [ActivityItem.phone, ActivityItem.message]
      let contact = DataSource.contact[indexPath.row]
      cell.detailImage = contact.image
      cell.headlineText = contact.name
      cell.subheadlineText = contact.title
      cell.descriptionText = contact.address
      cell.activityControl.addActivities(activities)

  // Optionally, adjust activity item size (defaults to `CGSize(width: 25.0, height: 25.0)`)
      self.activityControl.itemSize = CGSize(width: 25, height: 25)
  // Optionally, adjust limit on visible items in activity control (defaults to `3`)
      self.activityControl.maxVisibleItems = 3
  // Optionally, adjust activity control spacing (defaults to `29.0`)
      self.activityControl.stackView.spacing = 29.0

      //Add an action handler delegate to ContactCell, conforming to ContactCellDelegate protocol.
      cell.delegate = self
      return cell
  }

  //Implement this method to handle activity action.
  func contactCell(_ contactCell: ContactCell, didSelectActivity activityItem: ActivityItem) {
      let indexPath = self.tableView.indexPath(for: contactCell)!
      let targetContact = DataSource.contact[indexPath.row]
      switch activityItem {
          case ActivityItem.phone:
             targetContact.call()
          case ActivityItem.message:
             targetContact.sendMessage()
          default:
             break
      }
  }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit11ContactCell")
@interface ContactCell : NibDesignableTableViewCell
/**
  Reuse identifier
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The FioriImageView holds a detail image.
*/
@property (nonatomic, weak) IBOutlet FioriImageView * _Null_unspecified detailImageView;
/**
  The UILabel holds headline text.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified headlineLabel;
/**
  The UILabel holds subheadline text.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified subheadlineLabel;
/**
  The UILabel holds description text.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified descriptionLabel;
/**
  The ActivityControl object used in ContactCell.
*/
@property (nonatomic, weak) IBOutlet ActivityControl * _Null_unspecified activityControl;
/**
  Default main stack right edge is set at midpoint of cell’s readable width, minus 8px. Set to fraction between 0.01 and 0.99, to move the right edge of the \code
  mainStack
  \endcode, relative to the cell readable width.
  <blockquote>
  Important:  the percentage of readable width includes area often containing other subviews.  So, a valid value is typically between 30% and 70%.

  </blockquote>
  Only used when \code
  horizontalSizeClass
  \endcode of the object cell is \code
  .regular
  \endcode.
*/
@property (nonatomic) CGFloat mainStackWidth;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
/**
  Image of ContactCell.
*/
@property (nonatomic, strong) UIImage * _Nullable detailImage;
/**
  Property to preserve \code
  detailImageView
  \endcode spacing.  When it’s set to true, spacing is preserved for \code
  detailImageView
  \endcode even when there’s no image added to the image view
*/
@property (nonatomic) BOOL preserveDetailImageSpacing;
/**
  Text of headline label.
*/
@property (nonatomic, copy) NSString * _Nonnull headlineText;
/**
  Text of subheadline label.
*/
@property (nonatomic, copy) NSString * _Nonnull subheadlineText;
/**
  Text of \code
  descriptionLabel
  \endcode.
*/
@property (nonatomic, copy) NSString * _Nonnull descriptionText;
/**
  :nodoc:
*/
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
/**
  :nodoc:
*/
- (void)didMoveToWindow;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end

@class NSDateFormatter;
@class UIDatePicker;

/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to allow user to choose a date using date picker for a property.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following properties in its implementation
  of tableView \code
  cellForRowAt
  \endcode function:
  <ul>
    <li>
      \code
      keyName
      \endcode: The key name of the property.
    </li>
    <li>
      \code
      date
      \endcode: The default date of the property.
    </li>
    <li>
      \code
      delegate
      \endcode: An implementation of FormCellDelegate.
    </li>
  </ul>
  Optionally, UITableViewController could provide
  <ul>
    <li>
      \code
      dateFormatter
      \endcode: The DateFormatter to display the value of the date.
    </li>
    <li>
      \code
      datePickerMode
      \endcode: The UIDatePickerMode for the date picker. Default is .dateAndTime. Note that .countDownTimer is not supported.
    </li>
    <li>
      \code
      isEditable
      \endcode: Indicates if this cell could be modified or not. The default is true.
    </li>
  </ul>
  The \code
  UITableViewController
  \endcode implementation should maintain the date through the changes via \code
  formCell(_:didChangeValueTo:)
  \endcode delegate function.
  Here are the code snippets in app’s \code
  UITableViewController
  \endcode implementation:
  \code

         var propValue5:Date = ...

         override func viewDidLoad() {
             super.viewDidLoad()
             self.tableView.register(DatePickerFormCell.self, forCellReuseIdentifier: DatePickerFormCell.reuseIdentifier)
             // ...
         }

         override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
             // ...
             let cell = tableView.dequeueReusableCell(withIdentifier: DatePickerFormCell.reuseIdentifier, for: indexPath) as! DatePickerFormCell
             cell.keyName = "End Date"
             cell.value = propValue5
             cell.dateFormatter = dateFormatter
             cell.datePickerMode = .date
             cell.delegate = self

             return cell
             // ...
         }

         func didChangeValue<T: FormCell>(in formCell: T) {
             propValue5 = (formCell as! DatePickerFormCell).value
         }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit18DatePickerFormCell")
@interface DatePickerFormCell : NibDesignableTableViewCell
/**
  The value of the property.
*/
@property (nonatomic, copy) NSDate * _Nonnull value;
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  Indicates if the value of the cell could be changed or not.
  The default is true.
*/
@property (nonatomic) BOOL isEditable;
/**
  The key name of the property.
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  The placeholer text for the value text field.
*/
@property (nonatomic, copy) NSString * _Nullable placeholderText;
/**
  The \code
  DateFormatter
  \endcode to be used to display the selected
  \code
  Date
  \endcode. Default formatter:
  <ul>
    <li>
      for \code
      UIDatePickerMode.dateAndTime
      \endcode it is medium date style followed by short time style.
    </li>
    <li>
      for \code
      UIDatePickerMode.date
      \endcode it is medium date style
    </li>
    <li>
      for \code
      UIDatePickerMode.time
      \endcode it is short time style
    </li>
  </ul>
*/
@property (nonatomic, strong) NSDateFormatter * _Nullable dateFormatter;
/**
  The \code
  UIDatePickerMode
  \endcode for the \code
  UIDatePicker
  \endcode for this cell.
  The default value is \code
  UIDatePickerMode.dateAndTime
  \endcode.
  Note that \code
  UIDatePickerMode.countDownTimer
  \endcode is not allowed here.
*/
@property (nonatomic) UIDatePickerMode datePickerMode;
/**
  The \code
  UIDatePicker
  \endcode for this cell.
  It will be displayed only when this cell is selected.
*/
@property (nonatomic, readonly, strong) UIDatePicker * _Nonnull datePicker;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  \code
  FilterFormCell
  \endcode is a variant of \code
  UITableViewCell
  \endcode defined in \code
  FioriUIKit
  \endcode. It contains an \code
  UILabel
  \endcode and an \code
  UICollectionView
  \endcode.
  <h2>Code usage:</h2>
  \code
  //Define a variable in controller to hold selected value. Default value can be assigned here.
  var selectedValues: [Int]? = [0, 1]

  //Register FilterFormCell in viewDidLoad() method in the controller.
  override func viewDidLoad() {
      super.viewDidLoad()
      self.tableView.register(FilterFormCell.self, forCellReuseIdentifier: FilterFormCell.reuseIdentifier)
      // ...
  }

  //Implement following three data source methods in the controller.
  override func numberOfSections(in tableView: UITableView) -> Int {
     return 1
  }

  override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
     return 1
  }

  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      let cell = tableView.dequeueReusableCell(withIdentifier: FilterFormCell.reuseIdentifier, for: indexPath) as! FilterFormCell
      let valueOptions = ["item1", "item2", "item3", "item4", "item5", "item6"]
      cell.valueOptions = valueOptions
      cell.keyName = "Sort By"
      cell.value = selectedValues
      cell.allowsMultipleSelection = true
      cell.allowsEmptySelection = true
      cell.delegate = self
      return cell
  }

  //Implement formCell delegate method in the controller.
  func didChangeValue<T: FormCell>(in formCell: T) {
      selectedValue = (formCell as! FilterFormCell).value
  }

  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit14FilterFormCell")
@interface FilterFormCell : NibDesignableTableViewCell <UICollectionViewDataSource, UICollectionViewDelegateFlowLayout>
/**
  Reuse identifier
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  Indicate whether the user can select an item or not. It is set to true by default.
*/
@property (nonatomic) BOOL isEditable;
/**
  The value of the cell.
*/
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull value;
/**
  The array of the valid options.
*/
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull valueOptions;
/**
  The key name of the cell.
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  Indicates if user can select multiple values. It’s true by default.
*/
@property (nonatomic) BOOL allowsMultipleSelection;
/**
  The array of selected indexes.
*/
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull selectedIndexes;
/**
  Indicates if empty selection is allowed.
*/
@property (nonatomic) BOOL allowsEmptySelection;
/**
  The UILabel holds the key name string.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified keyLabel;
/**
  The collection view containing items to be displayed.
*/
@property (nonatomic, weak) IBOutlet UICollectionView * _Null_unspecified collectionView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView * _Nonnull)collectionView;
/**
  :nodoc:
*/
- (NSInteger)collectionView:(UICollectionView * _Nonnull)collectionView numberOfItemsInSection:(NSInteger)section;
/**
  :nodoc:
*/
- (UICollectionViewCell * _Nonnull)collectionView:(UICollectionView * _Nonnull)collectionView cellForItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)collectionView:(UICollectionView * _Nonnull)collectionView didSelectItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)collectionView:(UICollectionView * _Nonnull)collectionView didDeselectItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (BOOL)collectionView:(UICollectionView * _Nonnull)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end

@class FioriCollectionViewFlowLayout;
@class UINib;
@class UIButton;

/**
  This FioriCollectionView has the following components
  <ul>
    <li>
      Title label: display the title for this collection
    </li>
    <li>
      Action button: an optional button that invokes the didSelectAction function of its fioriCollectionViewDelegate when tapped. This button is enabled if the actionText property is set.
    </li>
    <li>
      Chevron image: includes an action button that is invoked when tapped. The action button is similar to that of the didSelectAction function of fioriCollectionViewDelegate.
    </li>
    <li>
      Collection view: displays all the items in the collection.
    </li>
  </ul>
  When using a FioriCollectionView either by code or using NIB, after getting an
  instance of FioriCollectionView, we recommend that you set its fioriCollectionViewFlowLayout
  property for the desired layout. Otherwise, a default layout is assigned
  with the following properties:
  <ul>
    <li>
      type: horizontalScroll
    </li>
    <li>
      itemSize: CGSize(width: 100, height: 100)
    </li>
    <li>
      minimumInteritemSpacing: 0
    </li>
    <li>
      minimumLineSpacing: 0
    </li>
  </ul>
  These code snippets demonstrate how to use FioriCollectionView:
  \code
  let fioriCollectionView = FioriCollectionView(frame: CGRect(...))
  let layout = FioriCollectionViewFlowLayout(type: type)

  // Set any custom layout here.
  layout.itemSize = CGSize(width: 100, height: 100)
  layout.minimumInteritemSpacing = 0
  layout.minimumLineSpacing = 0
  // Sets the flow layout to FioriCollectionView
  fioriCollectionView.fioriCollectionViewFlowLayout = layout

  fioriCollectionView.dataSource = testData
  fioriCollectionView.fioriCollectionViewDelegate = delegate
  fioriCollectionView.titleText = "Available Items"
  fioriCollectionView.actionText = "See All"

  \endcodeIf FioriCollectionView is to be used in a UITableViewCell, we recommend that you set
  the leading and trailing constraints of the FioriCollectionView to the UITableViewCell’s
  layoutMarginsGuide. The height of the cell can be derived from the verticalViewHeight
  function of the FioriCollectionView.
  The UICollectionViewDataSource and UICollectionViewDelegate can be set to the embeded
  CollectionView using the dataSource and delegate properties. Or, the app can directly
  set them to the embeded collectionView.
*/
SWIFT_CLASS("_TtC10FioriUIKit19FioriCollectionView")
@interface FioriCollectionView : NibDesignable
/**
  The text for the title lable.
*/
@property (nonatomic, copy) NSString * _Nullable titleText;
/**
  The text for the action button.
  If this is not set, or if it is set to nil, the action button will
  be hidden.
*/
@property (nonatomic, copy) NSString * _Nullable actionText;
/**
  The title label. Its text is from titleText.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified titleLabel;
/**
  The action button. Its text is from actionText property.
  If actionText is nil, this action button will not be shown.
*/
@property (nonatomic, weak) IBOutlet UIButton * _Null_unspecified actionButton;
/**
  The collection view containing items to be displayed.
*/
@property (nonatomic, weak) IBOutlet UICollectionView * _Null_unspecified collectionView;
/**
  The FioriCollectionViewFlowLayout for the collection view.
  If app does not set this property, a default layout is assigned
  with the following properties:
  <ul>
    <li>
      type: horizontalScroll
    </li>
    <li>
      itemSize: CGSize(width: 100, height: 100)
    </li>
    <li>
      minimumInteritemSpacing: 0
    </li>
    <li>
      minimumLineSpacing: 0
    </li>
  </ul>
*/
@property (nonatomic, strong) FioriCollectionViewFlowLayout * _Nullable fioriCollectionViewFlowLayout;
/**
  The UICollectionViewDataSource for the collection view.
*/
@property (nonatomic, strong) id <UICollectionViewDataSource> _Nullable dataSource;
/**
  The UICollectionViewDelegate for the collection view.
*/
@property (nonatomic, strong) id <UICollectionViewDelegate> _Nullable delegate;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (IBAction)actionButtonTapped:(id _Nonnull)sender;
/**
  Register a UICollectionViewCell class to be used in this CollectionView.
  Please refer to the similar function in UICollectionView.
  \param cellClass The class of a cell that you want to use in the collection view.

  \param identifier The reuse identifier to associate with the
  specified nib file. This parameter must not be an empty string.

*/
- (void)register:(Class _Nullable)cellClass forCellWithReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  Register a UINib to be used in this CollectionView.
  Please refer to the similar function in UICollectionView.
  Please note that the same function signature as the
  similar function in UICollectionView cannot be used here,
  that would cause swift compiler error.
  \param nib The nib object containing the view object.
  The nib file must contain only one top-level object and that object must
  be of the type UICollectionReusableView.

  \param identifier The reuse identifier to associate with the
  specified nib file. This parameter must not be an empty string.

*/
- (void)registerWithNib:(UINib * _Nullable)nib forCellWithReuseIdentifier:(NSString * _Nonnull)identifier;
/**
  :nodoc:
*/
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
/**
  :nodoc:
*/
- (void)prepareForInterfaceBuilder;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


SWIFT_CLASS("_TtC10FioriUIKit31NibDesignableCollectionViewCell")
@interface NibDesignableCollectionViewCell : UICollectionViewCell
@property (nonatomic, readonly, strong) UIView * _Nonnull nibContainerView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  FioriCollectionViewCell is a variant of \code
  UICollectionViewCell
  \endcode defined in \code
  FioriUIKit
  \endcode. It contains a \code
  UIImageView
  \endcode and a \code
  UILabel
  \endcode.
  Image is a square with size 60 x 60. Width of label is 94.
  \code
  FioriCollectionViewCell
  \endcode is also a square with size 126 x 126. <em>Set the itemSize property of collection view’s layout object to CGSize(width: 126, height: 126). See code usage below</em>
  <h2>Code usage:</h2>
  Implement collectionView(_:cellForItemAt:) dataSource method
  \code

  //Implement collectionView(_:cellForItemAt:) dataSource method
  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
      let cell = collectionView.dequeueReusableCell(withReuseIdentifier: FioriCollectionViewCell.reuseIdentifier, for: indexPath) as! FioriCollectionViewCell

      //configure cell
      cell.contentImage = UIImage()
      cell.titleText = "Title"

      return cell
  }


  \endcodeCreate and assign a layout object to collection view
  \code

  let layout = UICollectionViewFlowLayout()

  // Set any custom layout here.
  layout.itemSize = CGSize(width: 126, height: 126)   //Set itemSize explicitly!
  layout.minimumInteritemSpacing = 10
  layout.minimumLineSpacing = 10

  // Sets the flow layout to CollectionView
  collectionView.collectionViewLayout = layout
  collectionView.dataSource = DataSourceClass()
  collectionView.register(FioriCollectionViewCell.self, forCellWithReuseIdentifier: FioriCollectionViewCell.reuseIdentifier)


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit23FioriCollectionViewCell")
@interface FioriCollectionViewCell : NibDesignableCollectionViewCell
/**
  Reuse identifier
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  Image of \code
  FioriCollectionViewCell
  \endcode
*/
@property (nonatomic, strong) UIImage * _Nullable contentImage;
/**
  Title of \code
  FioriCollectionViewCell
  \endcode
*/
@property (nonatomic, copy) NSString * _Nullable titleText;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  This is a subclass of \code
  UICollectionViewFlowLayout
  \endcode to be used in
  \code
  FioriCollectionView
  \endcode. Please refer to \code
  UICollectionViewFlowLayout
  \endcode
  for its usage in \code
  UICollectionView
  \endcode.
*/
SWIFT_CLASS("_TtC10FioriUIKit29FioriCollectionViewFlowLayout")
@interface FioriCollectionViewFlowLayout : UICollectionViewFlowLayout
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
@property (nonatomic, readonly) CGSize collectionViewContentSize;
/**
  Calculate the height requirement for the FioriCollectionView.
  \param width The width of the view to contain this FioriCollectionView.


  returns:
  The height to show all items in this FioriCollectionView, including
  the title label for .vertical type. For other types, the height to show one
  row of items, including the title lable.
*/
- (CGFloat)verticalViewHeightFor:(CGFloat)width;
/**
  :nodoc:
*/
- (NSInteger)numberOfWholeItemsInARow;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class UIColor;

/**
  \code
  FioriImageView
  \endcode is an enhanced \code
  UIImageView
  \endcode that provides the option of applying a circular mask to the view’s \code
  image
  \endcode property. The view also exposes properties for specifying the width and color of an optional border around the image.
  remark:

  Implements \code
  @IBDesignable
  \endcode
  <h2>Usage</h2>
  <ul>
    <li>
      Initializing programatically:
    </li>
  </ul>
  \code
  let imageView = FioriImageView(image: UIImage(named: "myProfilePic"))
  //set image view to be circular
  imageView.isCircular = true

  \endcode<ul>
    <li>
      Placing inside a Storyboard or xib:
    </li>
  </ul>
  <ol>
    <li>
      Drag and drop an \code
      UIImageView
      \endcode component to Interface Builder canvas.
    </li>
    <li>
      Switch class name from  \code
      UIImageView
      \endcode to \code
      FioriImageView', and set module to
      \endcodeFioriUIKit`.
    </li>
    <li>
      To apply, set \code
      @IBInspectable
      \endcode property \code
      isCircular
      \endcode, to \code
      true
      \endcode
    </li>
  </ol>
*/
SWIFT_CLASS("_TtC10FioriUIKit14FioriImageView")
@interface FioriImageView : UIImageView
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image highlightedImage:(UIImage * _Nullable)highlightedImage OBJC_DESIGNATED_INITIALIZER;
/**
  Property defining the circular type of the image view.  Default is false, which has no ciruclar mask to the image
*/
@property (nonatomic) BOOL isCircular;
/**
  Property defining the border color.
*/
@property (nonatomic, strong) UIColor * _Nonnull borderColor;
/**
  Property defining the border width. A width of 0.0 will
  result in no border being shown.
*/
@property (nonatomic) float borderWidth;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)prepareForInterfaceBuilder;
@end

@class UITableView;
@class UIScrollView;
@class UIViewController;
@class NSBundle;

/**
  When \code
  FormCell
  \endcodes are to be used in an application, application’s implementation of
  \code
  UITableViewController
  \endcode that hosts these \code
  FormCell
  \endcodes must be a subclass of this
  \code
  FormTableViewController
  \endcode. \code
  FormTableViewController
  \endcode hides all the complications
  and interactions for handling all different types of FormCells.
  Application’s implementation of the \code
  UITableViewController
  \endcode needs to only
  implement the following functions:
  \code

  class FormCellTestTVC: FormTableViewController, FormCellDelegate {
     override func viewDidLoad() {
         // MUST: Call viewDidLoad function of super class.
         super.viewDidLoad()

         // Register FormCells that will be used
         self.tableView.register(TitleFormCell.self, forCellReuseIdentifier: TitleFormCell.reuseIdentifier)
         ...
     }

     override func numberOfSections(in tableView: UITableView) -> Int {
         // Return how many section in the table
         return ...
     }

     override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
         // Return number of rows in each section
         ...
     }

     override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
         // Return the cell to be used at the IndexPath specified
         let cell = tableView.dequeueReusableCell(withIdentifier: TitleFormCell.reuseIdentifier, for: indexPath) as! TitleFormCell
         cell.value = "Work Request"
         return cell
     }

     // MARK: - FormCellDelegate
     func didChangeValue<T : FormCell>(in formCell: T) {
         let indexPath = self.tableView.indexPath(for: formCell as! UITableViewCell)

         // use indexPath to find the corresponding cell
         ...
     }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit23FormTableViewController")
@interface FormTableViewController : UITableViewController
/**
  :nodoc:
*/
- (void)viewDidLoad;
/**
  :nodoc:
*/
- (void)viewDidAppear:(BOOL)animated;
/**
  :nodoc:
*/
- (void)tableView:(UITableView * _Nonnull)tableView didSelectRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath;
/**
  :nodoc:
*/
- (void)scrollViewWillBeginDragging:(UIScrollView * _Nonnull)scrollView;
/**
  :nodoc:
*/
- (void)scrollViewDidEndDragging:(UIScrollView * _Nonnull)scrollView willDecelerate:(BOOL)decelerate;
/**
  :nodoc:
*/
- (void)navigationControllerPresent:(UIViewController * _Nonnull)viewControllerToPresent animated:(BOOL)flag completion:(void (^ _Nullable)(void))completion;
/**
  :nodoc:
*/
- (void)navigationControllerPush:(UIViewController * _Nonnull)viewControllerToPush animated:(BOOL)flag;
- (nonnull instancetype)initWithStyle:(UITableViewStyle)style OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UITextField;

/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to display a key-value pair property. A table containing a list of optional values is provided for user to do either single choice or multiple choices from the list.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following in its implementation of tableView \code
  cellForRowAt
  \endcode function:
  <ul>
    <li>
      \code
      keyName
      \endcode: The key name of the property.
    </li>
    <li>
      \code
      value
      \endcode: The default selections.
    </li>
    <li>
      \code
      delegate
      \endcode: An implementation of \code
      FormCellDelegate
      \endcode.
    </li>
    <li>
      \code
      valueOptions
      \endcode: The list of optional values user may choose from. If \code
      isSingleSelect
      \endcode is true, only the first value in the list will be used.
    </li>
    <li>
      \code
      allowsMultipleSelection
      \endcode: Indicates if user can select multiple values. Default is true, meaning by default user may select multiple values.
    </li>
    <li>
      \code
      pickerPrompt
      \endcode: The title to be displayed on the section footer of the selection list table view. If this is not set, there will be no section footer on the selection list table view.
    </li>
    <li>
      \code
      isEditable
      \endcode: If the selection(s) could be modified or not. The default is true.
    </li>
  </ul>
  Here are the code snippets in app’s \code
  UITableViewController
  \endcode implementation:
  (The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode.)
  \code

         var propValue7: [Int] = [1, 3, 6]

         override func viewDidLoad() {
             super.viewDidLoad()
             self.tableView.register(ListPickerFormCell.self, forCellReuseIdentifier: ListPickerFormCell.reuseIdentifier)
             // ...
         }

         override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
             // ...
             let cell = tableView.dequeueReusableCell(withIdentifier: ListPickerFormCell.reuseIdentifier, for: indexPath) as! ListPickerFormCell
             cell.keyName = "Choose Multiple"
             cell.value = propValue7
             cell.valueOptions = ["One", "Two", "Three", "Four", "Five", "Six", "Seven"]
             cell.allowsMultipleSelection = true
             cell.pickerPrompt = "Please select multiple items"
             cell.delegate = self

             return cell
             // ...
         }

         func didChangeValue<T: FormCell>(in formCell: T) {
             propValue7 = (formCell as! ListPickerFormCell).value
         }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit18ListPickerFormCell")
@interface ListPickerFormCell : NibDesignableTableViewCell
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The value is the selected strings.
*/
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull value;
/**
  Indicates if this cell is editable or not,
  i.e., the selections could be changed or not.
  The default is true.
*/
@property (nonatomic) BOOL isEditable;
/**
  The key name of the property.
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  The array of the valid options.
*/
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull valueOptions;
/**
  Indicates if user can select multiple values.
  Default is true, meaning by default user may select multiple values.
*/
@property (nonatomic) BOOL allowsMultipleSelection;
/**
  Indicates if empty selection is allowed.
  Default is true, meaning by default user must select at least one item.
*/
@property (nonatomic) BOOL allowsEmptySelection;
/**
  The title to be displayed on the section header of the selection list table view.
  If this is not set, there will be no section header on the selection list table view.
*/
@property (nonatomic, copy) NSString * _Nullable pickerPrompt;
/**
  The UILabel holds the key name string.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified keyLabel;
/**
  The UITextField holds the selected value strings.
*/
@property (nonatomic, weak) IBOutlet UITextField * _Null_unspecified valueTextField;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end

@class UIActivityIndicatorView;
@class UIBarButtonItem;
@class UIControl;
@class UINavigationBar;
@class UIProgressView;
@class UINavigationItem;
@class UISearchBar;
@class UISegmentedControl;
@class UISlider;
@class UISwitch;
@class UIPageControl;
@class UITabBar;
@class UITabBarItem;
@class UIToolbar;
@class UITextView;
@class UIWindow;
@class NSNotification;

SWIFT_CLASS("_TtC10FioriUIKit11NUIRenderer")
@interface NUIRenderer : NSObject
+ (void)renderActivityIndicatorWithActivityIndicator:(UIActivityIndicatorView * _Nonnull)activityIndicator;
+ (void)renderActivityIndicatorWithActivityIndicator:(UIActivityIndicatorView * _Nonnull)activityIndicator withClass:(NSString * _Nonnull)className;
+ (void)renderBarButtonItemWithItem:(UIBarButtonItem * _Nonnull)item;
+ (void)renderBarButtonItemWithItem:(UIBarButtonItem * _Nonnull)item withClass:(NSString * _Nonnull)className;
+ (void)renderButtonWithButton:(UIButton * _Nonnull)button;
+ (void)renderButtonWithButton:(UIButton * _Nonnull)button withClass:(NSString * _Nonnull)className;
+ (void)renderControlWithControl:(UIControl * _Nonnull)control;
+ (void)renderControlWithControl:(UIControl * _Nonnull)control withClass:(NSString * _Nonnull)className;
+ (void)renderLabelWithLabel:(UILabel * _Nonnull)label;
+ (void)renderLabelWithLabel:(UILabel * _Nonnull)label withClass:(NSString * _Nonnull)className;
+ (void)renderLabelWithLabel:(UILabel * _Nonnull)label withClass:(NSString * _Nonnull)className withSuffix:(NSString * _Nonnull)suffix;
+ (void)renderImageViewWithImageView:(UIImageView * _Nonnull)imageView withClass:(NSString * _Nonnull)className;
+ (void)renderNavigationBarWithBar:(UINavigationBar * _Nonnull)bar;
+ (void)renderNavigationBarWithBar:(UINavigationBar * _Nonnull)bar withClass:(NSString * _Nonnull)className;
+ (void)renderProgressViewWithProgressView:(UIProgressView * _Nonnull)progressView;
+ (void)renderProgressViewWithProgressView:(UIProgressView * _Nonnull)progressView withClass:(NSString * _Nonnull)className;
+ (void)renderNavigationItemWithItem:(UINavigationItem * _Nonnull)item;
+ (void)renderNavigationItemWithItem:(UINavigationItem * _Nonnull)item withClass:(NSString * _Nonnull)className;
+ (void)renderSearchBarWithBar:(UISearchBar * _Nonnull)bar;
+ (void)renderSearchBarWithBar:(UISearchBar * _Nonnull)bar withClass:(NSString * _Nonnull)className;
+ (void)renderSegmentedControlWithControl:(UISegmentedControl * _Nonnull)control;
+ (void)renderSegmentedControlWithControl:(UISegmentedControl * _Nonnull)control withClass:(NSString * _Nonnull)className;
+ (void)renderSliderWithSlider:(UISlider * _Nonnull)slider;
+ (void)renderSliderWithSlider:(UISlider * _Nonnull)slider withClass:(NSString * _Nonnull)className;
+ (void)renderSwitchWithUiSwitch:(UISwitch * _Nonnull)uiSwitch;
+ (void)renderSwitchWithUiSwitch:(UISwitch * _Nonnull)uiSwitch withClass:(NSString * _Nonnull)className;
+ (void)renderPageControlWithPageControl:(UIPageControl * _Nonnull)pageControl;
+ (void)renderPageControlWithPageControl:(UIPageControl * _Nonnull)pageControl withClass:(NSString * _Nonnull)className;
+ (void)renderTabBarWithBar:(UITabBar * _Nonnull)bar;
+ (void)renderTabBarWithBar:(UITabBar * _Nonnull)bar withClass:(NSString * _Nonnull)className;
+ (void)renderTabBarItemWithItem:(UITabBarItem * _Nonnull)item;
+ (void)renderTabBarItemWithItem:(UITabBarItem * _Nonnull)item withClass:(NSString * _Nonnull)className;
+ (void)renderTableViewWithTableView:(UITableView * _Nonnull)tableView;
+ (void)renderTableViewWithTableView:(UITableView * _Nonnull)tableView withClass:(NSString * _Nonnull)className;
+ (void)renderTableViewCellWithCell:(UITableViewCell * _Nonnull)cell;
+ (void)renderTableViewCellWithCell:(UITableViewCell * _Nonnull)cell withClass:(NSString * _Nonnull)className;
+ (void)renderToolbarWithBar:(UIToolbar * _Nonnull)bar;
+ (void)renderToolbarWithBar:(UIToolbar * _Nonnull)bar withClass:(NSString * _Nonnull)className;
+ (void)renderTextFieldWithTextField:(UITextField * _Nonnull)textField;
+ (void)renderTextFieldWithTextField:(UITextField * _Nonnull)textField withClass:(NSString * _Nonnull)className;
+ (void)renderTextViewWithTextView:(UITextView * _Nonnull)textView;
+ (void)renderTextViewWithTextView:(UITextView * _Nonnull)textView withClass:(NSString * _Nonnull)className;
+ (void)renderViewWithView:(UIView * _Nonnull)view;
+ (void)renderViewWithView:(UIView * _Nonnull)view withClass:(NSString * _Nonnull)className;
+ (void)renderViewWithView:(UIView * _Nonnull)view withClass:(NSString * _Nonnull)className withSuffix:(NSString * _Nonnull)suffix;
+ (void)renderWindowWithWindow:(UIWindow * _Nonnull)window;
+ (void)renderWindowWithWindow:(UIWindow * _Nonnull)window withClass:(NSString * _Nonnull)className;
+ (BOOL)needsTextTransformWithClassWithClassName:(NSString * _Nonnull)className;
+ (NSString * _Nonnull)transformTextWithText:(NSString * _Nonnull)text withClass:(NSString * _Nonnull)className;
+ (void)sizeDidChangeForNavigationBarWithBar:(UINavigationBar * _Nonnull)bar;
+ (void)sizeDidChangeForTabBarWithBar:(UITabBar * _Nonnull)bar;
+ (void)sizeDidChangeForTableViewCellWithCell:(UITableViewCell * _Nonnull)cell;
+ (void)sizeDidChangeForTableViewWithTableView:(UITableView * _Nonnull)tableView;
+ (void)addOrientationDidChangeObserverWithObserver:(id _Nonnull)observer;
+ (void)removeOrientationDidChangeObserverWithObserver:(id _Nonnull)observer;
+ (void)rerender;
+ (void)rerenderViewWithView:(UIView * _Nonnull)view;
+ (void)setRerenderOnOrientationChangeWithRerender:(BOOL)rerender;
+ (NUIRenderer * _Nonnull)getInstance;
+ (void)orientationDidChangeWithNotification:(NSNotification * _Nonnull)notification;
+ (void)stylesheetFileChanged;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIFont;

SWIFT_CLASS("_TtC10FioriUIKit11NUISettings")
@interface NUISettings : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) NUISettings * _Null_unspecified instance;)
+ (NUISettings * _Null_unspecified)instance;
+ (void)setInstance:(NUISettings * _Null_unspecified)value;
+ (void)initWithStylesheetWithName:(NSString * _Nonnull)name SWIFT_METHOD_FAMILY(none);
+ (void)appendStylesheetWithName:(NSString * _Nonnull)name;
+ (void)loadStylesheetByPathWithPath:(NSString * _Nonnull)path;
+ (void)loadStylesheetByURLWithUrl:(NSURL * _Nonnull)url;
+ (void)reloadStylesheets;
+ (BOOL)reloadStylesheetsOnOrientationChangeWithOrientation:(UIInterfaceOrientation)orientation;
+ (BOOL)autoUpdateIsEnabled;
+ (NSString * _Nullable)autoUpdatePath;
+ (void)setAutoUpdatePathWithPath:(NSString * _Nonnull)path;
+ (BOOL)hasPropertyWithProperty:(NSString * _Nonnull)property withExplicitClass:(NSString * _Nonnull)className;
+ (BOOL)hasPropertyWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (BOOL)hasFontPropertiesWithClassWithClassName:(NSString * _Nonnull)className;
+ (NSString * _Nullable)getWithProperty:(NSString * _Nonnull)property withExplicitClass:(NSString * _Nonnull)className;
+ (NSString * _Nullable)getWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (BOOL)getBooleanWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UITextBorderStyle)getBorderStyleWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UITableViewCellSeparatorStyle)getSeparatorStyleWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIFont * _Nullable)getFontWithClassWithClassName:(NSString * _Nonnull)className;
+ (UIFont * _Nonnull)getFontWithClassWithClassName:(NSString * _Nonnull)className baseFont:(UIFont * _Nullable)baseFont;
+ (UIColor * _Nullable)getColorWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIColor * _Nullable)getColorFromImageWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIImage * _Nullable)getImageFromColorWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIImage * _Nullable)getImageWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIBarStyle)getBarStyleWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (NSTextAlignment)getTextAlignmentWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIControlContentHorizontalAlignment)getControlContentHorizontalAlignmentWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIControlContentVerticalAlignment)getControlContentVerticalAlignmentWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (UIKeyboardAppearance)getKeyboardAppearanceWithProperty:(NSString * _Nonnull)property withClass:(NSString * _Nonnull)className;
+ (NSArray<NSString *> * _Nonnull)getClassesWithClassName:(NSString * _Nonnull)className;
+ (void)setGlobalExclusionsWithArray:(NSArray<NSString *> * _Nonnull)array;
+ (NSArray<NSString *> * _Nonnull)getGlobalExclusions;
+ (NSString * _Nullable)stylesheetOrientation;
+ (NSString * _Nonnull)stylesheetOrientationFromInterfaceOrientationWithOrientation:(UIInterfaceOrientation)orientation;
+ (NUISettings * _Nonnull)getInstance;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




@class SZTextViewNoteCellExt;

/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to allow user enter notes.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following in its implementation of tableView \code
  cellForRowAt
  \endcode function:
  <ul>
    <li>
      \code
      delegate
      \endcode: An implementation of FormCellDelegate to be notified when there are changes to the cell.
    </li>
  </ul>
  Optionally, \code
  UITableViewController
  \endcode could provide:
  <ul>
    <li>
      \code
      value
      \endcode: The default text in the note.
    </li>
    <li>
      \code
      placeholderText
      \endcode: The placeholder string to be put on the text area before user typed anything.
    </li>
    <li>
      \code
      isAutoFitting
      \endcode: If this is true, the scroll will be disabled and the height of the
      cell will grow and shrink as needed. There is a minimum height that the cell
      will maintain.
    </li>
    <li>
      \code
      isEditable
      \endcode: Indicates if the note text could be modified or not. The default is true.
    </li>
  </ul>
  Here are the code snippets in app’s UITableViewController implementation:
  \code

         override func viewDidLoad() {
             super.viewDidLoad()
             self.tableView.register(NoteFormCell.self, forCellReuseIdentifier: NoteFormCell.reuseIdentifier)
             // ...
         }

         var noteText = "This is a test"

         override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
             // ...
             let cell = tableView.dequeueReusableCell(withIdentifier: NoteFormCell.reuseIdentifier, for: indexPath) as! NoteFormCell
             cell.delegate = self

             // App could specify a default text in the note by setting the value of the note cell
             cell.value = noteText
             // Or, app could specify a placeholder before user typed anything.
             // cell.placeholderText = "Description"

             return cell
             // ...
         }

         func didChangeValue<T: FormCell>(in formCell: T) {
             noteText = (formCell as! NoteFormCell).value
         }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit12NoteFormCell")
@interface NoteFormCell : NibDesignableTableViewCell <UITextViewDelegate>
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The note string.
*/
@property (nonatomic, copy) NSString * _Nonnull value;
/**
  Indicates if the note text could be modified or not.
  The default is true.
*/
@property (nonatomic) BOOL isEditable;
/**
  The placeholder string to be put on the text area
  before user typed anything.
*/
@property (nonatomic, copy) NSString * _Nullable placeholderText;
/**
  The UI component holds the note text.
*/
@property (nonatomic, weak) IBOutlet SZTextViewNoteCellExt * _Null_unspecified noteText;
/**
  If \code
  isTrackingLiveChanges
  \endcode is true, \code
  didChangeValue
  \endcode function of delegate
  will be invoked for every letter entered.
  Otherwise, \code
  didChangeValue
  \endcode function will be invoked only after
  user tapped “Done” key or another cell is selected.
  The default value is false.
*/
@property (nonatomic) BOOL isTrackingLiveChanges;
/**
  If this is true, this \code
  NoteFormCell
  \endcode will grow in height and the
  cell will not be scrollable.
  Otherwise, the cell height will be fixed.
*/
@property (nonatomic) BOOL isAutoFitting;
/**
  This is the maximum length of the note text, if maxNoteTextLength is greater than 0.
  If the text length reaches this limit, the user cannot enter more text.
  Note: If the user pastes a string and the length plus
  the current text length is greater than the limit, the insert
  is rejected. Partial strings are not accepted in the text field.
  The default value for maxNoteTextLength is 0, which means no limit.
*/
@property (nonatomic) NSInteger maxNoteTextLength;
/**
  The type of the keyboard being used when the cell is in input mode.
*/
@property (nonatomic) UIKeyboardType keyboardType;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (BOOL)resignFirstResponder;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (BOOL)textViewShouldBeginEditing:(UITextView * _Nonnull)textView;
/**
  :nodoc:
*/
- (void)textViewDidEndEditing:(UITextView * _Nonnull)textView;
/**
  :nodoc:
*/
- (void)textViewDidChange:(UITextView * _Nonnull)textView;
/**
  :nodoc:
*/
- (BOOL)textView:(UITextView * _Nonnull)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString * _Nonnull)text;
@end

@class UIStackView;

/**
  \code
  ObjectCell
  \endcode is an Interface-Builder-designable UI component that extends \code
  UITableViewCell
  \endcode for showing information of an object.  It contains a set of default content views which are common to Fiori Design Language Object Cell types, with the associated constraint implementations and handling for size classes.
  <h2>Views Available in ObjectCell:</h2>
  <ul>
    <li>
      \code
      iconsStackView
      \endcode:  an UIStackView view expected to contain a vertical stack of icons/images in its view content.  The view is added to the cell unless \code
      cell.preserveIconStackSpacing
      \endcode is set to \code
      false
      \endcode.  This is the first view in the cell and can be left to \code
      detailImageView
      \endcode.  Use \code
      cell.iconImages
      \endcode to add image(s) to the stack view.  Each icon/image size is set to be \code
      16px
      \endcode by \code
      16px
      \endcode.
    </li>
    <li>
      \code
      detailImageView
      \endcode: a FioriImageView view added to the cell unless \code
      cell.preserveDetailImageSpacing
      \endcode is set to \code
      false
      \endcode.   The view is right to \code
      iconsStackView
      \endcode and left to \code
      headlineLabel
      \endcode.  The image is scaled to fit with fixed aspect.  The image size is set to \code
      45px
      \endcode by \code
      45px
      \endcode.  Use \code
      cell.detailImage
      \endcode to set image
    </li>
    <li>
      \code
      headlineLabel
      \endcode: an UILabel view is always displayed and intended to display a heandline text in the cell.  Use `cell.headlineText” to set label text
    </li>
    <li>
      \code
      subheadlineLabel
      \endcode: an UILabel view is added 3px below \code
      headlineLabel
      \endcode to the cell. Use `cell.subheadlineText” to set label text
    </li>
    <li>
      \code
      footnoteLabel
      \endcode: an UILabel view is added 3px below \code
      subheadLabel
      \endcode to the cell. Use `cell.footnoteText” to set label text
    </li>
    <li>
      \code
      descriptionLabel
      \endcode: an UILabel view tended to display a long text in the cell.  It gets displayed only in regular view.  The view is right to \code
      headlineLabel
      \endcode and left to \code
      statusImageView
      \endcode(or \code
      statusLabel
      \endcode).  Use `cell.descriptionText” to set label text
    </li>
    <li>
      \code
      statusImageView
      \endcode/\code
      statusLabel
      \endcode: an UIImageView/UILabel added to the cell for status.  \code
      statusImageView
      \endcode gets added with size \code
      16px
      \endcode by \code
      16px
      \endcode.  The view is left to accessory view and right to \code
      descriptionLabel
      \endcode.  Use \code
      cell.statusText
      \endcode to set label text or \code
      cell.statusImage
      \endcode to set image.
    </li>
    <li>
      \code
      substatusImageView
      \endcode/\code
      substatusLabel
      \endcode: an UIImageView/UILabel added to the cell under status.  \code
      substatusImageView
      \endcode gets added with size \code
      16px
      \endcode by \code
      16px
      \endcode.  Use \code
      cell.substatusText
      \endcode to set label text or \code
      cell.substatusImage
      \endcode to set image.  When \code
      accessoryType
      \endcode is not \code
      .none
      \endcode nor \code
      .disclosureIndicator
      \endcode, setting a substatus label text or substatus image throws an assertion failure as this setting breaks Fiori Design Language pattern.
    </li>
    <li>
      \code
      accessoryView
      \endcode:  an UIView added to the view when \code
      cell.accessoryType
      \endcode is not \code
      .none
      \endcode.  The view is an UIButton customized in ObjectCell and is aligned to the base-line of \code
      headlineLabel
      \endcode when the type is \code
      .disclosureIndicator
      \endcode.  For any other types, it’s vertically center-aligned and created by Apple native SDK.
    </li>
  </ul>
  <h2>Example Initialization and Configuration:</h2>
  \code
  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
      let cell = tableView.dequeueReusableCell(withIdentifier: ObjectTableViewCell.reuseIdentifier, for: indexPath as IndexPath) as! ObjectTableViewCell
      cell.detailImage = UIImage(named: "ProfilePic")
      cell.headlineText = "Edgar Scissorhands"
      cell.subheadlineText = "Lorem ipsum datil es iosin Lotios nsiqok"
      cell.footnoteText = "Here is some footer text about Edward"
      cell.statusImageView.image = UIImage(named: "ErrorIcon")
      cell.substatusText = "Active"
      cell.descriptionText = "This text is only visible when the cell is in regular horizontal size class."
      cell.iconImages = [#imageLiteral(resourceName: "clock"), #imageLiteral(resourceName: "check"), #imageLiteral(resourceName: "attention")]
      cell.accessoryType = .disclosureIndicator
      return cell
  }

  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit10ObjectCell")
@interface ObjectCell : NibDesignableTableViewCell
/**
  Reuse identifier
  @return String a reuse identifier that describes ObjectCell
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  Icons Stack view that contains a stack of icons/images in its contents.  Each icon/image size is set to be \code
  16px
  \endcode by \code
  16px
  \endcode.  Count of visible images is limited, to the count of active labels in the main stack
*/
@property (nonatomic, strong) IBOutlet UIStackView * _Null_unspecified iconsStackView;
/**
  Detail image view that contains an image with size of 45px x 45px
*/
@property (nonatomic, strong) IBOutlet FioriImageView * _Null_unspecified detailImageView;
/**
  A headline label in the main view with UIFontTextStyleHeadline style setting as the preferred font.  Use \code
  headlineText
  \endcode to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified headlineLabel;
/**
  A sub-header label in the main view with UIFontTextStyleBody style setting as the preferred font.  Use \code
  subheadlineText
  \endcode to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified subheadlineLabel;
/**
  A footnote label in the main view with UIFontTextStyleSubheadline style setting as the preferred font.  Use \code
  footnoteText
  \endcode to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified footnoteLabel;
/**
  A description label displayed in the description view when size class is .regular.  Use \code
  descriptionText
  \endcode to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified descriptionLabel;
/**
  A status label displayed in the status view.  Use \code
  statusText
  \endcode to set the label’s text value.  Status Label and status image can not co-exist in display.  When both are set, the last one set gets displayed only.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified statusLabel;
/**
  A status image displayed in the status view.  Use \code
  stuatsImage
  \endcode to set an image.  It’s expected to either set \code
  statusText
  \endcode or \code
  statusImage
  \endcode to display either one as the same position.  When both \code
  statusText
  \endcode and \code
  statusImage
  \endcode are set, the last property set gets displayed only.
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified statusImageView;
/**
  A substatus label displayed below \code
  statusImageView
  \endcode or \code
  statusLabel
  \endcode. Use \code
  substatusLabel
  \endcode to set the label’s text value.  It’s expected to either set \code
  substatusText
  \endcode or \code
  substatusImage
  \endcode to display either one as the same position.  When both \code
  statusText
  \endcode and \code
  statusImage
  \endcode are set, the last property set gets displayed only.  When \code
  accessoryType
  \endcode is not \code
  .none
  \endcode nor \code
  .disclosureIndicator
  \endcode, setting substatus label text throws an assertion failure as this setting breaks Fiori Design Language pattern.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified substatusLabel;
/**
  A substatus image displayed below \code
  statusImageView
  \endcode or \code
  statusLabel
  \endcode. Use \code
  substatusImage
  \endcode to set an image to the view.  It’s expected to either set \code
  stubsatusText
  \endcode or \code
  substatusImage
  \endcode to display either one as the same position.  When both \code
  substatusText
  \endcode and \code
  substatusImage
  \endcode are set, the last property set gets displayed only.  When \code
  accessoryType
  \endcode is not \code
  .none
  \endcode nor \code
  .disclosureIndicator
  \endcode, setting a substatus image throws an assertion failure as this setting breaks Fiori Design Language pattern.
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified substatusImageView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  Array of images, to be rendered in \code
  iconStackView
  \endcode.  Count of visible images is limited, to the count of active labels in the main stack.
*/
@property (nonatomic, copy) NSArray<UIImage *> * _Nonnull iconImages;
/**
  Property to preserve \code
  iconStackView
  \endcode spacing.  When it’s set to \code
  true
  \endcode, spacing is preserved for \code
  iconStackView
  \endcode even when there’s no icons/images added to the icon stack
*/
@property (nonatomic) BOOL preserveIconStackSpacing;
/**
  Property to set image of \code
  DetailImageView
  \endcode
*/
@property (nonatomic, strong) UIImage * _Nullable detailImage;
/**
  Property to preserve \code
  detailImageView
  \endcode spacing.  When it’s set to true, spacing is preserved for \code
  detailImageView
  \endcode even when there’s no image added to the image view
*/
@property (nonatomic) BOOL preserveDetailImageSpacing;
/**
  Text of \code
  headlineLabel
  \endcode
*/
@property (nonatomic, copy) NSString * _Nonnull headlineText;
/**
  Text of \code
  subheadlineLabel
  \endcode.  The label is initially hidden.  Setting a non-empty value would no longer hide the label.
*/
@property (nonatomic, copy) NSString * _Nonnull subheadlineText;
/**
  Text of \code
  footnoteLabel
  \endcode.  The label is initially hidden.  Setting a non-empty value would no longer hide the label.
*/
@property (nonatomic, copy) NSString * _Nonnull footnoteText;
/**
  Text of \code
  descriptionLabel
  \endcode.
*/
@property (nonatomic, copy) NSString * _Nonnull descriptionText;
/**
  Text of \code
  statusLabel
  \endcode .  An empty string value hides \code
  statusLabel
  \endcode.  It’s expected to either set \code
  statusText
  \endcode or \code
  statusImage
  \endcode to display either one as the same position.  When both \code
  statusText
  \endcode and \code
  statusImage
  \endcode are set, the last property set gets displayed only.
*/
@property (nonatomic, copy) NSString * _Nonnull statusText;
/**
  Image of status image view
*/
@property (nonatomic, strong) UIImage * _Nullable statusImage;
/**
  Text of substatus label.
*/
@property (nonatomic, copy) NSString * _Nonnull substatusText;
/**
  Image of substatus image view.
*/
@property (nonatomic, strong) UIImage * _Nullable substatusImage;
/**
  Type of the accessory view
*/
@property (nonatomic) UITableViewCellAccessoryType accessoryType;
/**
  Default main stack right edge is set at midpoint of cell’s readable width, minus 8px. Set to fraction between 0.01 and 0.99, to move the right edge of the \code
  mainStack
  \endcode, relative to the cell readable width.
  <blockquote>
  Important:  the percentage of readable width includes area often containing other subviews.  So, a valid value is typically between 30% and 70%.

  </blockquote>
  Only used when \code
  horizontalSizeClass
  \endcode of the object cell is \code
  .regular
  \endcode.
*/
@property (nonatomic) CGFloat mainStackWidth;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)layoutMarginsDidChange;
/**
  :nodoc:
*/
- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)willTransitionToState:(UITableViewCellStateMask)state;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
/**
  :nodoc:
*/
- (void)didMoveToWindow;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  This is the base class of \code
  PasscodeCreateController
  \endcode and \code
  PasscodeInputController
  \endcode.
  It has the common codes for those two view controllers.
  Note that both Passcode screen and Touch ID screen are supported for portrait orientation only.
  The app needs to switch to portrait mode before presenting these screens.
  And AppDelegate needs to lock the screen orientation when these screens are shown, similar to the following code snippet.
  In app’s AppDelegate:
  \code

  public var inPasscodeView: Bool = false

  // implement this function to support only portrait orientation when PasscodeView is displayed.
  func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
      if !inPasscodeView {
          return .allButUpsideDown
      } else {
          return .portrait
      }
  }


  \endcodeBefore presenting the Passcode or Touch ID screen:
  \code

  // Let AppDelegate know that we are entering PasscodeView
  (UIApplication.shared.delegate as! AppDelegate).inPasscodeView = true

  // Make sure we rotate to portrait mode
  let value = UIInterfaceOrientation.portrait.rawValue
  UIDevice.current.setValue(value, forKey: "orientation")
  // Present the passcode view
  self.navigationController?.present(navController, animated: true, completion: nil)


  \endcodeAfter dismissing the Passcode or Touch ID screen:
  \code

  passcodeController.dismiss(animated: true, completion: nil)
  // Let AppDelegate know that we are exiting PasscodeView
  (UIApplication.shared.delegate as! AppDelegate).inPasscodeView = false


  \endcodeThe strings used in \code
  PasscodeSetupView
  \endcode, \code
  PasscodeView
  \endcode, and \code
  TouchIDView
  \endcode
  are from localized Onboarding.strings file.
  Application can override these strings by setting the corresponding static
  variables in this PasscodeController class at runtime.
*/
SWIFT_CLASS("_TtC10FioriUIKit18PasscodeController")
@interface PasscodeController : UIViewController
/**
  The title for the passcode setup screens.
  The default is from localized strings file - “Set Passcode”.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable setPasscodeTitleString;)
+ (NSString * _Nullable)setPasscodeTitleString;
+ (void)setSetPasscodeTitleString:(NSString * _Nullable)value;
/**
  The title for the enter passcode screen.
  The default is from localized strings file - “Passcode”.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable passcodeTitleString;)
+ (NSString * _Nullable)passcodeTitleString;
+ (void)setPasscodeTitleString:(NSString * _Nullable)value;
/**
  The message on the confirm passcode screen.
  The default is from localized strings file - “Confirm your passcode”.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable confirmPasscodeString;)
+ (NSString * _Nullable)confirmPasscodeString;
+ (void)setConfirmPasscodeString:(NSString * _Nullable)value;
/**
  The message on the input passcode screen.
  The default is from localized strings file - “Enter your passcode”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable enterYourPasscodeMessageString;)
+ (NSString * _Nullable)enterYourPasscodeMessageString;
+ (void)setEnterYourPasscodeMessageString:(NSString * _Nullable)value;
/**
  The button title string used both in passcode and
  touch ID screens to indicate not to setup now.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable notNowButtonString;)
+ (NSString * _Nullable)notNowButtonString;
+ (void)setNotNowButtonString:(NSString * _Nullable)value;
/**
  The button title string used on the second passcode setup
  to go back to the first screen.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable backItemString;)
+ (NSString * _Nullable)backItemString;
+ (void)setBackItemString:(NSString * _Nullable)value;
/**
  The button title string used on the first passcode setup
  to go to the next screen.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable nextItemString;)
+ (NSString * _Nullable)nextItemString;
+ (void)setNextItemString:(NSString * _Nullable)value;
/**
  The main message format on the setup passscode screen.
  The %d will display the number of characters required from
  the passcode policy.
  The default format is from localized strings file -
  “Choose a passcode with a minimum of %d characters”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable setPasscodeMessageFormat;)
+ (NSString * _Nullable)setPasscodeMessageFormat;
+ (void)setSetPasscodeMessageFormat:(NSString * _Nullable)value;
/**
  The main message format on the setup passscode screen when the
  isDititsOnly property of the passcode policy is true.
  The %d will display the number of digits required from
  the passcode policy.
  The default format is from localized strings file -
  “Choose a passcode with a minimum of %d digits”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable setPasscodeWithDigitsMessageFormat;)
+ (NSString * _Nullable)setPasscodeWithDigitsMessageFormat;
+ (void)setSetPasscodeWithDigitsMessageFormat:(NSString * _Nullable)value;
/**
  The message format for choosing passcode from the number of character groups
  when passcode policy requires it.
  The default format is from localized strings file -
  “Include at least %d of the following:”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable chooseMinGroupsMessageFormat;)
+ (NSString * _Nullable)chooseMinGroupsMessageFormat;
+ (void)setChooseMinGroupsMessageFormat:(NSString * _Nullable)value;
/**
  The group name for lower case letters.
  The default string is from localized strings file -
  “Lower case (a-z)”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable lowerCaseLabelString;)
+ (NSString * _Nullable)lowerCaseLabelString;
+ (void)setLowerCaseLabelString:(NSString * _Nullable)value;
/**
  The group name for upper case letters.
  The default string is from localized strings file -
  “Upper case (A-Z)”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable upperCaseLabelString;)
+ (NSString * _Nullable)upperCaseLabelString;
+ (void)setUpperCaseLabelString:(NSString * _Nullable)value;
/**
  The group name for digits.
  The default string is from localized strings file -
  “Digits (0-9)”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable digitsLabelString;)
+ (NSString * _Nullable)digitsLabelString;
+ (void)setDigitsLabelString:(NSString * _Nullable)value;
/**
  The group name for non-alphabetic characters.
  The default string is from localized strings file -
  “Non-alphabetic (!@#…)”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable nonAlphabeticLabelString;)
+ (NSString * _Nullable)nonAlphabeticLabelString;
+ (void)setNonAlphabeticLabelString:(NSString * _Nullable)value;
/**
  The button title for resetting passcode.
  The default string is from localized strings file -
  “Reset Passcode”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable resetPasscodeButtonString;)
+ (NSString * _Nullable)resetPasscodeButtonString;
+ (void)setResetPasscodeButtonString:(NSString * _Nullable)value;
/**
  Alert message when validate method of PasscodeValidationDelegate
  returning false for the passcode user entered in setup passcode.
  The default string is from localized strings file -
  “Passcode validation failed.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable passcodeValidationFailedMessageString;)
+ (NSString * _Nullable)passcodeValidationFailedMessageString;
+ (void)setPasscodeValidationFailedMessageString:(NSString * _Nullable)value;
/**
  Alert message when the passcode user entered was rejected by
  the PasscodeControllerDelegate’s shouldTryPasscode function.
  The default string is from localized strings file -
  “Passcode was rejected by PasscodeControllerDelegate.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable passcodeRejectedMessageString;)
+ (NSString * _Nullable)passcodeRejectedMessageString;
+ (void)setPasscodeRejectedMessageString:(NSString * _Nullable)value;
/**
  The alert button title used on passcode validation failed, or passcode rejected.
  The default is from localized strings file - “Retry”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable retryButtonString;)
+ (NSString * _Nullable)retryButtonString;
+ (void)setRetryButtonString:(NSString * _Nullable)value;
/**
  The title for setup touch ID screen.
  The default string is from localized strings file -
  “Touch ID”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable touchIDTitleString;)
+ (NSString * _Nullable)touchIDTitleString;
+ (void)setTouchIDTitleString:(NSString * _Nullable)value;
/**
  The first paragraph of the message on the Touch ID screen.
  The default string is from localized strings file -
  “Enabling Touch ID will allow quick access to your information.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable touchIDMessage1String;)
+ (NSString * _Nullable)touchIDMessage1String;
+ (void)setTouchIDMessage1String:(NSString * _Nullable)value;
/**
  The second paragraph of the message on the Touch ID screen.
  The default string is from localized strings file -
  “You can turn this feature On or Off anytime from Settings.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable touchIDMessage2String;)
+ (NSString * _Nullable)touchIDMessage2String;
+ (void)setTouchIDMessage2String:(NSString * _Nullable)value;
/**
  The message for the link on the Touch ID screen.
  The default string is from localized strings file -
  “Learn more about Touch ID”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable learnMoreTouchIDLinkString;)
+ (NSString * _Nullable)learnMoreTouchIDLinkString;
+ (void)setLearnMoreTouchIDLinkString:(NSString * _Nullable)value;
/**
  The button title to enable Touch ID authentication.
  The default is from localized strings file - “Enable”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable enableButtonString;)
+ (NSString * _Nullable)enableButtonString;
+ (void)setEnableButtonString:(NSString * _Nullable)value;
/**
  The message displayed when authticate with Touch ID.
  The default string is from localized strings file -
  “Authenticate with Touch ID”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable authticateWithTouchIDMessageString;)
+ (NSString * _Nullable)authticateWithTouchIDMessageString;
+ (void)setAuthticateWithTouchIDMessageString:(NSString * _Nullable)value;
/**
  The message when the passcode entered in confirm passcode screen
  does not match with the one entered in the setup passcode screen.
  The default string is from localized strings file -
  “Passcodes did not match. Try again.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable passcodeNotMatchMessageString;)
+ (NSString * _Nullable)passcodeNotMatchMessageString;
+ (void)setPasscodeNotMatchMessageString:(NSString * _Nullable)value;
/**
  The message format to be displayed when user entered wrong passcode
  and the remaining number of retries is greater than 1.
  The default format is from localized strings file -
  “You hava %d attempts left”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable attemptsLeftMessageFormat;)
+ (NSString * _Nullable)attemptsLeftMessageFormat;
+ (void)setAttemptsLeftMessageFormat:(NSString * _Nullable)value;
/**
  The message string to be displayed when user entered wrong passcode
  and there is only one remaining retry.
  The default string is from localized strings file -
  “You have 1 attempt left”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable oneAttempLeftMessageFormat;)
+ (NSString * _Nullable)oneAttempLeftMessageFormat;
+ (void)setOneAttempLeftMessageFormat:(NSString * _Nullable)value;
/**
  The first paragraph of the alert message when the number user entered
  wrong passcode reached maximum allowed.
  The default string is from localized strings file -
  “Maximum Passcode Attempts Reached”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable maxAttemptsReachedMessageString;)
+ (NSString * _Nullable)maxAttemptsReachedMessageString;
+ (void)setMaxAttemptsReachedMessageString:(NSString * _Nullable)value;
/**
  The second paragraph of the alert message when the number user entered
  wrong passcode reached maximum allowed.
  The default string is from localized strings file -
  “Please enter your credentials to Sign in and reset the passcode”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable enterCredentialsMessageString;)
+ (NSString * _Nullable)enterCredentialsMessageString;
+ (void)setEnterCredentialsMessageString:(NSString * _Nullable)value;
/**
  The text of the dismiss button on the alert when the number user entered
  wrong passcode reached maximum allowed.
  The default string is from localized strings file -
  “OK”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable okButtonString;)
+ (NSString * _Nullable)okButtonString;
+ (void)setOkButtonString:(NSString * _Nullable)value;
/**
  The message on the passcode screen when user entered wrong passcode
  and there is no limit on the number of retries.
  The default string is from localized strings file -
  “Incorrect passcode. Try again.”
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable retryPasscodeMessageString;)
+ (NSString * _Nullable)retryPasscodeMessageString;
+ (void)setRetryPasscodeMessageString:(NSString * _Nullable)value;
/**
  :nodoc:
*/
- (void)viewDidLoad;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIStoryboardSegue;

/**
  This \code
  UIViewController
  \endcode is to be used by app to setup the passcode and enabling Touch ID screen flows.
  Before the navigation controller presents this \code
  PasscodeCreateController
  \endcode, the following properties
  needs to be setup:
  <ul>
    <li>
      delegate: An implementation of \code
      PasscodeControllerDelegate
      \endcode to hanle events from this controller.
    </li>
    <li>
      validationDelegate: An implementation of \code
      PasscodeValidationDelegate
      \endcode to validate the passcode user entered.
    </li>
  </ul>
  Here is the screen flow:
  <ul>
    <li>
      The first screen prompts user to enter passcode.
      After user entered the passcode which is validated with the \code
      PasscodePolicy
      \endcode
      the \code
      PasscodeControllerDelegate
      \endcode provided, function \code
      validate
      \endcode of \code
      validationDelegate
      \endcode will be
      invoked for extra validations.
      If validation success, the next screen will be displayed.
    </li>
    <li>
      The second screen prompts user to enter passcode again to verify with the passcode
      entered in the first screen. The third screen will be displayed when the passcode
      entered matched the passcode entered and touch ID is allowed in PasscodePolicy.
    </li>
    <li>
      The third screen prompts user to decide if enable Touch ID authentication or not.
      If user chooses “Enable” the passcode is saved as a Touch ID protected keychain item
      so that the passcode could be retrieved by PasscodeInputController later with Touch ID.
    </li>
  </ul>
  After the setup is done, either with the third screen or not, the function \code
  shouldTryPasscode
  \endcode
  of the \code
  PasscodeControllerDelegate
  \endcode is invoked. The delegate should either create a secure
  store with the passcode, or save the passcode in a secure manner.
  This passcode create flow is implemented in \code
  PasscodeCreateController.storyboard
  \endcode. There are two ways to invoke it:
  <ul>
    <li>
      Use another story board and using a “Present Modally” segue to \code
      PasscodeCreateController
      \endcode storyboard in \code
      FioriUIKit
      \endcode framework bundle.
      App programmer needs to provide the properties needed in \code
      UIController
      \endcode’s prepare for segue function:
    </li>
  </ul>
  \code

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
      let destination = segue.destination as! UINavigationController
      let vc0 = destination.viewControllers[0]
      let vc = vc0 as! PasscodeCreateController
      vc.delegate = passcodeControllerDelegate
      vc.isSkipPasscodeAllowed = true
  }


  \endcode<ul>
    <li>
      Programmatically loads it:
    </li>
  </ul>
  \code

  let storyboard = UIStoryboard(name: "PasscodeCreateController", bundle: bundle)
  let vc = storyboard.instantiateViewController(withIdentifier: "PasscodeCreateFirstViewController")
  let passcodeVC = vc as! PasscodeCreateController
  passcodeVC.isSkipPasscodeAllowed = true
  // present the passcode view
  let navController = UINavigationController(rootViewController: passcodeVC)
  self.navigationController?.present(navController, animated: true, completion: nil)


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit24PasscodeCreateController")
@interface PasscodeCreateController : PasscodeController
/**
  Indicates if user is allowed to skip passcode setup.
  If this is true, there will be a “Not Now” button user can tap to skip passcode setup process.
*/
@property (nonatomic) BOOL isSkipPasscodeAllowed;
/**
  App may set this link to other values. The default link URL is “https://support.apple.com/en-us/HT201371”.
  This link is to be used in the Touch ID screen with label “Learn more about Touch ID”
*/
@property (nonatomic, copy) NSURL * _Nullable touchIDLearnMoreLink;
/**
  :nodoc:
*/
- (void)viewDidLoad;
/**
  :nodoc:
*/
- (void)viewWillAppear:(BOOL)animated;
/**
  :nodoc:
*/
- (void)viewWillDisappear:(BOOL)animated;
/**
  :nodoc:
*/
- (void)viewDidAppear:(BOOL)animated;
/**
  :nodoc:
*/
- (void)prepareForSegue:(UIStoryboardSegue * _Nonnull)segue sender:(id _Nullable)sender;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  This \code
  UIViewController
  \endcode is to be used by app to authenticate user by either Touch ID or Passcode.
  Before the navigation controller presents this \code
  PasscodeInputController
  \endcode, the following properties
  needs to be setup:
  <ul>
    <li>
      delegate: An implementation of \code
      PasscodeControllerDelegate
      \endcode to handle events from this controller.
    </li>
  </ul>
  This controller will try to determine if Touch ID is enabled by retrieving the value from
  keychain. If Touch ID is enabled, there will be Touch ID authentication popup to prompt user
  authenticate with Touch ID.
  If Touch ID authentication succeeded, the saved passcode will be retrieved and function
  \code
  shouldTryPasscode
  \endcode of the \code
  PasscodeControllerDelegate
  \endcode implementation will be invoked.
  If Touch ID autheication is canceled or failed, the passcode view will be shown to prompt user
  enter passcode. After user entered the passcode, function \code
  shouldTryPasscode
  \endcode of the
  \code
  PasscodeControllerDelegate
  \endcode implementation will be invoked.
  The delegate should dismiss this controller after the passcode is verified.
  This passcode input flow is implemented in \code
  PasscodeInputController.storyboard
  \endcode. There are two ways to invoke it:
  <ul>
    <li>
      Use another story board and using a “Present Modally” segue to \code
      PasscodeInputController
      \endcode storyboard in \code
      FioriUIKit
      \endcode framework bundle.
      App programmer needs to provide the properties needed in \code
      UIController
      \endcode’s prepare for segue function:
    </li>
  </ul>
  \code

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
      let destination = segue.destination as! UINavigationController
      let vc0 = destination.viewControllers[0]
      let vc = vc0 as! PasscodeInputController
      vc.delegate = passcodeControllerDelegate
  }


  \endcode<ul>
    <li>
      Programmatically loads it:
    </li>
  </ul>
  \code

  let storyboard = UIStoryboard(name: "PasscodeInputController", bundle: bundle)
  let vc = storyboard.instantiateViewController(withIdentifier: "PasscodeInputViewController")
  let passcodeVC = vc as! PasscodeInputController

  // present the passcode view
  let navController = UINavigationController(rootViewController: passcodeVC)
  self.navigationController?.present(navController, animated: true, completion: nil)


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit23PasscodeInputController")
@interface PasscodeInputController : PasscodeController
/**
  App may provide a custom background image to be displayed under the Touch ID
  authentication popup.
*/
@property (nonatomic, strong) UIImage * _Nullable customBackgroundImage;
/**
  If this property is true, a Cancel bar button item will be shown.
  When that Cancel bar button item is tapped, the \code
  didCancelPasscodeEntry
  \endcode
  function of the delegate will be invoked.
  The default is false.
*/
@property (nonatomic) BOOL isToShowCancelBarItem;
/**
  :nodoc:
*/
- (void)viewDidLoad;
/**
  :nodoc:
*/
- (void)viewDidAppear:(BOOL)animated;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  PreviewHeaderTableViewCell ReuseUI cell for footer of PreviewSection
*/
SWIFT_CLASS("_TtC10FioriUIKit26PreviewFooterTableViewCell")
@interface PreviewFooterTableViewCell : UITableViewCell
/**
  Reuse identifier
  @return String a resue identifier that describes PreviewFooterTableViewCell
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  PreviewHeaderTableViewCell ReuseUI cell for header of PreviewSection
*/
SWIFT_CLASS("_TtC10FioriUIKit26PreviewHeaderTableViewCell")
@interface PreviewHeaderTableViewCell : UITableViewCell
/**
  Reuse identifier
  @return String a resue identifier that describes PreviewHeaderTableViewCell
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end

@class UITextPosition;
@class NSTextContainer;

/**
  :nodoc:
*/
SWIFT_CLASS("_TtC10FioriUIKit21SZTextViewNoteCellExt")
@interface SZTextViewNoteCellExt : SZTextView
/**
  :nodoc:
*/
- (BOOL)becomeFirstResponder;
/**
  :nodoc:
*/
- (CGRect)caretRectForPosition:(UITextPosition * _Nonnull)position;
- (nonnull instancetype)initWithFrame:(CGRect)frame textContainer:(NSTextContainer * _Nullable)textContainer OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/**
  \code
  SegmentedControlFormCell
  \endcode is a reusable UI component implemented as an \code
  UITableViewCell
  \endcode to represent a key-value pair property. Users can select a value among a set of buttons.
  Button selection could not be modified if \code
  isEditable
  \endcode propery of \code
  SegmentedControlFormCell
  \endcode is set to false.
  The button size is 73 * 32.
  <h2>Code usage:</h2>
  \code

  // Define a variable in controller to hold selected value. Default value can be assigned here.
  var items = ["Low", "Medium", "High"]
  var propKey9 = "Key"
  var selectedItemIndex9 = 1

  // Register SegmentedControlFormCell in viewDidLoad() method in the controller.
  override func viewDidLoad() {
     super.viewDidLoad()
     self.tableView.register(SegmentedControlFormCell.self, forCellReuseIdentifier: SegmentedControlFormCell.reuseIdentifier)
     // ...

  }

  // Implement following three data source methods in the controller.
  override func numberOfSections(in tableView: UITableView) -> Int {
     return 1
  }

  override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
     return 1
  }

  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
     let cell = tableView.dequeueReusableCell(withIdentifier: SegmentedControlFormCell.reuseIdentifier, for: indexPath) as! SegmentedControlFormCell
     cell.valueOptions = items
     cell.keyName = propKey9
     cell.value = selectedItemIndex9
     cell.delegate = self
     return cell
  }

  // Implement formCell delegate method in the controller.
  func didChangeValue<T: FormCell>(in formCell: T) {
      selectedItemIndex9 = (formCell as! SegmentedControlFormCell).value
  }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit24SegmentedControlFormCell")
@interface SegmentedControlFormCell : NibDesignableTableViewCell
/**
  Reuse identifier
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The key name of the cell
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  The value of the cell
*/
@property (nonatomic) NSInteger value;
/**
  The array of the valid options.
*/
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull valueOptions;
/**
  Indicates whether the user can change the selection or not. It is set to true by default.
*/
@property (nonatomic) BOOL isEditable;
/**
  Indicates whether the control attempts to adjust segment widths based on their content widths.
*/
@property (nonatomic) BOOL apportionsSegmentWidthsByContent;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (void)layoutSubviews;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to display a key-value pair property.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following in its implementation of tableView cellForRowAt function:
  <ul>
    <li>
      \code
      keyName
      \endcode: The key name of the property.
    </li>
    <li>
      \code
      value
      \endcode: The value of the property.
    </li>
    <li>
      \code
      delegate
      \endcode: An implementation of \code
      FormCellDelegate
      \endcode.
    </li>
    <li>
      \code
      isEditable
      \endcode: Indicates if the value is editable or not. This property is always false for \code
      SimplePropertyFormCell
      \endcode.
    </li>
  </ul>
  Here are the code snippets in app’s \code
  UITableViewController
  \endcode implementation:
  \code
         var propValue1: String = "test value1"

         override func viewDidLoad() {
             super.viewDidLoad()
             self.tableView.register(SimplePropertyFormCell.self, forCellReuseIdentifier: SimplePropertyFormCell.reuseIdentifier)
             // ...
         }

         override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
             // ...
             let cell = tableView.dequeueReusableCell(withIdentifier: SimplePropertyFormCell.reuseIdentifier, for: indexPath) as! SimplePropertyFormCell
             cell.keyName = "Editable"
             cell.value = propValue1
             cell.delegate = self

             return cell
             // ...
         }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit22SimplePropertyFormCell")
@interface SimplePropertyFormCell : NibDesignableTableViewCell
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The value of the property.
*/
@property (nonatomic, copy) NSString * _Nonnull value;
/**
  Indicates if the value of the cell could be changed or not.
  For \code
  SimplePropertyFormCell
  \endcode this property is always false.
*/
@property (nonatomic) BOOL isEditable;
/**
  The key name of the property.
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  The \code
  UILabel
  \endcode holds the key name string.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified keyLabel;
/**
  The \code
  UITextField
  \endcode holds the value string.
*/
@property (nonatomic, weak) IBOutlet UITextField * _Null_unspecified valueTextField;
/**
  If \code
  isTrackingLiveChanges
  \endcode is true, \code
  didChangeValue
  \endcode function of delegate
  will be invoked for every letter entered.
  Otherwise, delegate’s \code
  didChangeValue
  \endcode function will be invoked only after
  user tapped “Done” key or another cell is selected.
  The default value is false.
*/
@property (nonatomic) BOOL isTrackingLiveChanges;
/**
  The placeholer text for the value text field.
*/
@property (nonatomic, copy) NSString * _Nullable placeholderText;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (BOOL)resignFirstResponder;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to allow user to choose a boolean value using a switch for a property.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following in its implementation of tableView \code
  cellForRowAt
  \endcode function:
  <ul>
    <li>
      \code
      keyName
      \endcode: The key name of the property.
    </li>
    <li>
      \code
      value
      \endcode: The default boolean value of the property.
    </li>
    <li>
      \code
      delegate
      \endcode: An implementation of FormCellDelegate.
    </li>
    <li>
      \code
      isEditable
      \endcode: Indicates if the value could be modified or not. The default is true.
    </li>
  </ul>
  The \code
  TableViewController
  \endcode should maintain the boolean through the changes via \code
  formCell(_:didChangeValueTo:)
  \endcode delegate function.
  Here are the code snippets in app’s \code
  UITableViewController
  \endcode implementation:
  (The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode.)
  \code

    var propValue6: Bool = true
    override func viewDidLoad() {
        super.viewDidLoad()
        self.tableView.register(SwitchFormCell.self, forCellReuseIdentifier: SwitchFormCell.reuseIdentifier)
        // ...
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        // ...
        let cell = tableView.dequeueReusableCell(withIdentifier: SwitchFormCell.reuseIdentifier, for: indexPath) as! SwitchFormCell
        cell.keyName = "Confirmed"
        cell.value = propValue6
        cell.delegate = self
        return cell
        // ...
     }

     func didChangeValue<T: FormCell>(in formCell: T) {
        propValue6 = (formCell as! SwitchFormCell).value
     }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit14SwitchFormCell")
@interface SwitchFormCell : NibDesignableTableViewCell
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The value of the property. Default to be false.
*/
@property (nonatomic) BOOL value;
/**
  Indicates if the value of the cell could be changed or not.
  The default is true.
*/
@property (nonatomic) BOOL isEditable;
/**
  The key name of the property.
*/
@property (nonatomic, copy) NSString * _Nullable keyName;
/**
  The \code
  UILable
  \endcode displaying the key name field.
*/
@property (nonatomic, weak) IBOutlet UILabel * _Null_unspecified keyLabel;
/**
  The \code
  UISwitch
  \endcode displaying the boolean value.
*/
@property (nonatomic, strong) IBOutlet UISwitch * _Null_unspecified switchView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (void)valueChanged:(UISwitch * _Nonnull)sender;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  The \code
  TimelineCell
  \endcode in \code
  Timeline
  \endcode is enhanced and Interface-Builder-designable \code
  UITableViewCell
  \endcode controls that contain a set of content views with defined properties used to present information or events in chronological order.
  <ul>
    <li>
      \code
      TimelineCell
      \endcode is a selectable cell intended for timelines that require open and complete status that displays timeline  details.  Selecting the cell changes the card background color to the framework-preferred color: \code
      FioriUIColorStyle.line
      \endcode.
    </li>
    <li>
      It uses a vertical line and \code
      nodeImageView
      \endcode as a separator. Left to the vertical line is the timeline event stack view that contains \code
      eventLabel
      \endcode and \code
      eventImageView
      \endcode; right to the vertical line is the main stack view that contains \code
      headlineLabel
      \endcode and \code
      subheadlineLabel
      \endcode.
    </li>
    <li>
      Below the main view is an attribute stack view with \code
      attributeLabel
      \endcode and \code
      subAttributeLabel
      \endcode layed out horizontally.
    </li>
    <li>
      To the right of the main view is a status view that contains \code
      statusLabel
      \endcode, \code
      statusImage
      \endcode, \code
      substatusLabel
      \endcode, and \code
      substatusImage
      \endcode layed out vertically.
    </li>
  </ul>
  <h2>Usage</h2>
  \code

     override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
         let cell = tableView.dequeueReusableCell(withIdentifier: "TimelineCell", for: indexPath) as! TimelineCell
         cell.headlineText = "Planned Downtime Period Identified"
         cell.subheadlineText = "Work Package"
         cell.nodeImage = TimelineNode.open
         cell.eventText = "9:45\nAM"
         cell.eventImage = #imageLiteral(resourceName: "rain")
         cell.statusImage = #imageLiteral(resourceName: "ErrorIcon")
         cell.subStatusText = "Active"
         return cell
     }


  \endcode<h2>Notes</h2>
  <h4>SingleLine Sepatator Between Timeline Items in the Table</h4>
  Tableview’s default \code
  separatorStyle
  \endcode is \code
  .singleLine
  \endcode.  Because of this default setting, there can be a 1.0 px divider line or a separator in-between each item on the timeline in the table.  This is not an issue in timeline.  To get rid of the separator, set \code
  separatorStyle
  \endcode to \code
  none
  \endcode in the TabelViewController class
  \code

     override func viewDidLoad() {
         super.viewDidLoad()
         //...
         self.tableView.separatorStyle = .none
         //...
     }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit12TimelineCell")
@interface TimelineCell : NibDesignableTableViewCell
/**
  A headline label in the main view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  headlineText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified headlineLabel;
/**
  A subheadline label in the main view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  subheadlineText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified subheadlineLabel;
/**
  A status label in the status stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  statusText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified statusLabel;
/**
  A substatus label in the status stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  substatusText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified subStatusLabel;
/**
  A status image view in the status stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  statusImage
  \endcode property to set the image view’s image value
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified statusImageView;
/**
  A substatus image view in the status stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  substatusImage
  \endcode property to set the image view’s image value
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified subStatusImageView;
/**
  A event label in the cell’s left column.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  eventText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified eventLabel;
/**
  A event image view in the cell’s left column.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  eventImage
  \endcode property to set the image view’s image value
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified eventImageView;
/**
  A node image view, centered on the cell’s vertical timeline line.
  remark:
  Use \code
  TimelineNode
  \endcode static properties, to return standard Fiori Design Language node images
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified nodeImageView;
/**
  A attribute label in the footer horizontal stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  attributeText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified attributeLabel;
/**
  A subAttribute label in the footer horizontal stack view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  subAttributeText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified subAttributeLabel;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  Property defining the headline text.  An empty string value hides the headlineLabel
*/
@property (nonatomic, copy) NSString * _Nonnull headlineText;
/**
  Property defining the subheadline text.  An empty string value hides the subheadlineLabel
*/
@property (nonatomic, copy) NSString * _Nonnull subheadlineText;
/**
  Property defining the \code
  statusLabel.text
  \endcode value.  An empty string value hides the \code
  statusLabel
  \endcode.
  important:

  The \code
  statusLabel
  \endcode and \code
  statusImageView
  \endcode may not be displayed simultaneously.  When values exist for both \code
  statusText
  \endcode and \code
  statusImage
  \endcode, the last value set will be used.
*/
@property (nonatomic, copy) NSString * _Nonnull statusText;
/**
  Property defining the substatusLabel text.  An empty string value hides the subStatusLabel.  It’s expected to either set subStatusLabel or substatusImage to display either one as the same position.
*/
@property (nonatomic, copy) NSString * _Nonnull subStatusText;
/**
  Property defining the statusImageView image.  An empty value hides the statusImageView.  It’s expected to either set statusText or statusImage to display either one as the same position.  When both statusText and statusImage is not set, the substatusLabel or substatusImage takes statusLable/statusImage’s position.
*/
@property (nonatomic, strong) UIImage * _Nullable statusImage;
/**
  Property defining the substatusImageView image.  An empty value hides the substatusImageView.  It’s expected to either set substatusText or substatusImage to display either one as the same position.
*/
@property (nonatomic, strong) UIImage * _Nullable subStatusImage;
/**
  Property defining the eventLabel text.  An empty value hides the eventLabel
*/
@property (nonatomic, copy) NSString * _Nonnull eventText;
/**
  Property defining the eventImageView image. An empty value hides the eventImageView
*/
@property (nonatomic, strong) UIImage * _Nullable eventImage;
/**
  Property defining the node image.  Check with \code
  TimelineNode
  \endcode for a list of possible node images for different timeline status
*/
@property (nonatomic, strong) UIImage * _Nullable nodeImage;
/**
  Property defining the timeline width, which is the width of the whole event view left to the veritical line in the cell.  The default width is \code
  83.0
  \endcode px
*/
@property (nonatomic) CGFloat timelineWidth;
/**
  Property defining the attributeLabel text.  An empty value hides attributeLabel and subAttributeLabel text gets displayed at the original attributeLabel position.
*/
@property (nonatomic, copy) NSString * _Nonnull attributeText;
/**
  Property defining the subAttributeLabel text.  An empty value hides subAttributeLabel.
*/
@property (nonatomic, copy) NSString * _Nonnull subAttributeText;
/**
  :nodoc:
*/
- (void)prepareForInterfaceBuilder;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated;
/**
  :nodoc:
*/
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  The \code
  TimelineMarkerCell
  \endcode in \code
  Timeline
  \endcode is enhanced and Interface-Builder-designable \code
  UITableViewCell
  \endcode controls that contain a set of content views with defined properties used to present information or events in chronological order.
  <ul>
    <li>
      \code
      TimelineMarkerCell
      \endcode is a non-selectable with \code
      selectionStyle
      \endcode set to \code
      .none
      \endcode that is intended for timelines with start, inactive, early end, and end status that display timeline information.
    </li>
    <li>
      It uses a vertical line and a node image as a separator. Left to the vertical line is the timeline event section that contains \code
      eventLabel
      \endcode and \code
      eventImageView
      \endcode; right to the vertical line is \code
      titleLabel
      \endcode.
    </li>
    <li>
      The vertical line contains \code
      leadingTimeline
      \endcode on the top, \code
      nodeImageView
      \endcode in the middle, and a \code
      trailingTimeline
      \endcode at the bottom.
    </li>
  </ul>
  <h2>Usage</h2>
  \code

     override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
         let cell = tableView.dequeueReusableCell(withIdentifier: "TimelineMarkerCell", for: indexPath) as! TimelineMarkerCell
         cell.titleText = "Project Start"
         cell.nodeImage = TimelineNode.start
         cell.eventText = "12/6/15"
         cell.showLeadingTimeline = false
         return cell
     }


  \endcode<h2>Notes</h2>
  <h4>SingleLine Sepatator Between Timeline Items in the Table</h4>
  Tableview’s default \code
  separatorStyle
  \endcode is \code
  .singleLine
  \endcode.  Because of this default setting, there can be a 1.0 px divider line or a separator in-between each item on the timeline in the table.  This is not an issue in timeline.  To get rid of the separator, set \code
  separatorStyle
  \endcode to \code
  none
  \endcode in the TabelViewController class
  \code

      override func viewDidLoad() {
      super.viewDidLoad()
      // ...
      self.tableView.separatorStyle = .none
      // ...
  }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit18TimelineMarkerCell")
@interface TimelineMarkerCell : NibDesignableTableViewCell
/**
  A title label in the main view.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  titleText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified titleLabel;
/**
  A event label in the cell’s left column.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  eventText
  \endcode property to set the label’s text value
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified eventLabel;
/**
  A event image view in the cell’s left column.
  important:

  Use the \code
  @IBInspectable
  \endcode \code
  eventImage
  \endcode property to set the image view’s image value
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified eventImageView;
/**
  A node image view, centered on the cell’s vertical timeline line.
  remark:
  Use \code
  TimelineNode
  \endcode static properties, to return standard Fiori Design Language node images.
*/
@property (nonatomic, strong) IBOutlet UIImageView * _Null_unspecified nodeImageView;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  Property defining the titleLabel text.  An empty value hides titleLabel.
*/
@property (nonatomic, copy) NSString * _Nonnull titleText;
/**
  Property defining the eventLabel text.  An empty value hides the eventLabel
*/
@property (nonatomic, copy) NSString * _Nonnull eventText;
/**
  Property defining the eventImageView image. An empty value hides the eventImageView
*/
@property (nonatomic, strong) UIImage * _Nullable eventImage;
/**
  Property defining the node image.  Check with \code
  TimelineNode
  \endcode for a list of possible node images for different timeline status.
*/
@property (nonatomic, strong) UIImage * _Nullable nodeImage;
/**
  Property defining the timeline width, which is the width of the whole event view left to the veritical line in the cell.  The default width is \code
  83.0
  \endcode px
*/
@property (nonatomic) CGFloat timelineWidth;
/**
  Property defining the flag to show or not to show timeline’s leading vertical line.  Default is true.
*/
@property (nonatomic) BOOL showLeadingTimeline;
/**
  Property defining the flag to show or not to show timeline’s trailing vertical line.  Default is true.
*/
@property (nonatomic) BOOL showTrailingTimeline;
/**
  :nodoc:
*/
- (void)prepareForInterfaceBuilder;
/**
  :nodoc:
*/
- (void)prepareForReuse;
/**
  :nodoc:
*/
@property (nonatomic, copy) NSArray * _Nullable accessibilityElements;
/**
  :nodoc:
*/
- (NSInteger)accessibilityElementCount;
/**
  :nodoc:
*/
- (id _Nullable)accessibilityElementAtIndex:(NSInteger)index;
/**
  :nodoc:
*/
- (NSInteger)indexOfAccessibilityElement:(id _Nonnull)element;
@end


/**
  The reusable UI component implemented as an \code
  UITableViewCell
  \endcode to display title of this \code
  UITableView
  \endcode.
  The app’s \code
  UITableViewController
  \endcode needs to be a subclass of \code
  FormTableViewController
  \endcode
  and provide the following in its implementation of tableView \code
  cellForRowAt
  \endcode function:
  <ul>
    <li>
      \code
      value
      \endcode: The title text.
    </li>
    <li>
      \code
      delegate
      \endcode: An implementation of FormCellDelegate.
    </li>
    <li>
      \code
      isEditable
      \endcode: Indicates if this title is editable or not. If this is true, the \code
      UITableViewController
      \endcode needs to maintain the value change using delegate’s \code
      didChangeValue
      \endcode function.
    </li>
  </ul>
  Here are the code snippets in app’s \code
  UITableViewController
  \endcode implementation:
  \code

    var title2 = "Editable Title"
    override func viewDidLoad() {
        super.viewDidLoad()
        self.tableView.register(TitleFormCell.self, forCellReuseIdentifier: TitleFormCell.reuseIdentifier)
        // ...
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        // ...
        let cell = tableView.dequeueReusableCell(withIdentifier: TitleFormCell.reuseIdentifier, for: indexPath) as! TitleFormCell
        cell.value = title2
        cell.isEditable = true
        cell.delegate = self
        return cell
        // ...
    }

    func didChangeValue<T: FormCell>(in formCell: T) {
        title2 = (formCell as! TitleFormCell).value
    }


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit13TitleFormCell")
@interface TitleFormCell : NibDesignableTableViewCell <UITextFieldDelegate>
/**
  The default cell reuse identifier.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull reuseIdentifier;)
+ (NSString * _Nonnull)reuseIdentifier;
/**
  The value for TitleFormCell is the text of the Title.
*/
@property (nonatomic, copy) NSString * _Nonnull value;
/**
  Indicates if this title is editable or not.
  The default is false.
*/
@property (nonatomic) BOOL isEditable;
/**
  The UITextField to hold the title string.
*/
@property (nonatomic, weak) IBOutlet UITextField * _Null_unspecified titleTextField;
/**
  This is the maximum length of the title text, if maxTitleTextLength is greater than 0.
  If the text length reaches this limit, the user cannot enter more text.
  Note: If the user pastes a string and the length plus
  the current text length is greater than the limit, the insert
  is rejected. Partial strings are not accepted in the text field.
  The default value for maxTitleTextLength is 0, which means no limit.
*/
@property (nonatomic) NSInteger maxTitleTextLength;
/**
  The type of the keyboard being used when the cell is in input mode.
*/
@property (nonatomic) UIKeyboardType keyboardType;
/**
  If \code
  isTrackingLiveChanges
  \endcode is true, \code
  didChangeValue
  \endcode function of delegate
  will be invoked for every letter entered.
  Otherwise, \code
  didChangeValue
  \endcode function will be invoked only after
  user tapped “Done” key or another cell is selected.
  The default value is false.
*/
@property (nonatomic) BOOL isTrackingLiveChanges;
/**
  The placeholder text for the title text field.
*/
@property (nonatomic, copy) NSString * _Nullable placeholderText;
/**
  :nodoc:
*/
- (nonnull instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString * _Nullable)reuseIdentifier OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/**
  :nodoc:
*/
- (BOOL)resignFirstResponder;
/**
  :nodoc:
*/
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority;
/**
  :nodoc:
*/
- (BOOL)textField:(UITextField * _Nonnull)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString * _Nonnull)string;
@end


@interface UIActivityIndicatorView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIBarButtonItem (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIButton (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIColor (SWIFT_EXTENSION(FioriUIKit))
- (nonnull instancetype)initWithHexString:(NSString * _Nonnull)hex;
@end


@interface UIControl (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIFont (SWIFT_EXTENSION(FioriUIKit))
+ (UIFont * _Nonnull)preferredFioriFontForTextStyle:(UIFontTextStyle _Nonnull)textStyle;
@end


@interface UIFontDescriptor (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIImage (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIImage (SWIFT_EXTENSION(FioriUIKit))
- (UIImage * _Nullable)swiftStackBlurInRadius:(NSInteger)inRadius;
@end


@interface UIImageView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UILabel (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UILabel (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UILabel (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UINavigationBar (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UINavigationItem (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIPageControl (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIProgressView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UISearchBar (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UISegmentedControl (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UISlider (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIStackView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIStackView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIStackView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UISwitch (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITabBar (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITabBarItem (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITableView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITableViewCell (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITableViewCell (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITextField (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UITextView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIToolbar (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIView (SWIFT_EXTENSION(FioriUIKit))
@end


@interface UIView (SWIFT_EXTENSION(FioriUIKit))
@property (nonatomic, readonly, strong) UIView * _Nonnull nibContainerView;
/**
  Called in the default implementation of loadNib(). Default is class name.

  returns:
  Name of a single view nib file.
*/
- (NSString * _Nonnull)nibName;
@end


@interface UIView (SWIFT_EXTENSION(FioriUIKit))
@property (nonatomic, copy) NSString * _Nullable nuiClass;
@end


@interface UIWindow (SWIFT_EXTENSION(FioriUIKit))
@end


/**
  This \code
  UIViewController
  \endcode is used to display a welcome screen for the first time user onboard to the application.  The screen mainly displays the application name, instructions on how to start the activation process and an option to trigger the demo mode of the application.
  Application can conform to protocol \code
  OnboardingDelegate
  \endcode to present the demo mode of the application by adopting with the \code
  didSelectDemoMode()
  \endcode function
  \code
  WelcomeOnboardingScreen
  \endcode is implemented in \code
  WelcomOnboardingScreen.storyboard
  \endcode.  There are two ways to launch the screen:
  <ul>
    <li>
      Use another story board and using a “Present Modally” segue to \code
      WelcomOnboardingScreen
      \endcode storyboard in FioriUIKit framework bundle.
      App programmer needs to provide the properties needed in \code
      UIController
      \endcode’s prepare for segue function:
    </li>
  </ul>
  \code

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
     let vc = segue.destination as! WelcomeOnboardingScreen
     vc.view.layoutSubviews()
     vc.appNameLabel.text = "Project Assistant for Managers"
     welcomeScreenDelegate = TestWelcomeOnboardingScreenDelegate(self)
     vc.delegate = welcomeScreenDelegate
  }


  \endcode<ul>
    <li>
      Programmatically loads it:
    </li>
  </ul>
  \code

  let vc = WelcomeOnboardingScreen.createInstanceFromStoryboard()
  vc.appNameLabel.text = "Project Assistant for Managers"
  self.navigationController?.pushViewController(vc, animated: true)


  \endcodeNote that the WelcomeOnboardingScreen is supported for portrait orientation only.
  The app needs to switch to portrait mode before presenting the screen.
  And AppDelegate needs to lock the screen orientation when these screens are shown, similar to the following code snippet.
  In app’s AppDelegate:
  \code

  public var inWelcomeOnboardingScreen: Bool = false

  // implement this function to support only portrait orientation when WelcomeOnboardingScreen is displayed.
  func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask {
      if !inWelcomeOnboardingScreen {
          return .allButUpsideDown
     } else {
         return .portrait
     }
  }


  \endcodeBefore presenting the \code
  WelcomeOnboardingScreen
  \endcode:
  \code

  // Let AppDelegate know that we are entering the screen
  (UIApplication.shared.delegate as! AppDelegate).inWelcomeOnboardingScreen = true

  // Make sure we rotate to portrait mode
  let value = UIInterfaceOrientation.portrait.rawValue
  UIDevice.current.setValue(value, forKey: "orientation")

  // Present the screen
  let vc = WelcomeOnboardingScreen.createInstanceFromStoryboard()
  vc.appNameLabel.text = "Project Assistant for Managers"
  self.navigationController?.pushViewController(vc, animated: true)


  \endcodeAfter dismissing the Passcode or Touch ID screen:
  \code

  onboardingScreen.dismiss(animated: true, completion: nil)

  // Let AppDelegate know that we are exiting the view
  (UIApplication.shared.delegate as! AppDelegate).inWelcomeOnboardingScreen = false


  \endcode*/
SWIFT_CLASS("_TtC10FioriUIKit23WelcomeOnboardingScreen")
@interface WelcomeOnboardingScreen : UIViewController
/**
  Creates a \code
  WelcomeOnboardingScreen
  \endcode object from storyboard and intitialize subview compoennts.

  returns:
  A WelcomeOnboardingScreen object.
*/
+ (WelcomeOnboardingScreen * _Nonnull)createInstanceFromStoryboard;
/**
  Application name label.  Setting \code
  appNameLabel
  \endcode.text displays the application name on the screen.  Framework does not display any default text.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified appNameLabel;
/**
  Welcome label.  Setting \code
  welcomeLabel
  \endcode.text displays the welcome text on the screen; otherwise, framework displays the default text.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified welcomeLabel;
/**
  Thankyou label.  Setting \code
  thankyouLabel
  \endcode.text displays the thankyou note on the screen otherwise, framework displays the default text.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified thankyouLabel;
/**
  Instruction text view.  Setting \code
  instructionTextView
  \endcode.text displays the instruction statement on the screen; otherwise, framework displays the default text.
*/
@property (nonatomic, strong) IBOutlet UITextView * _Null_unspecified instructionTextView;
/**
  Demo label.  Setting \code
  demoLabel
  \endcode.text displays the demo message on the screen; otherwise, framework displays the default text.
*/
@property (nonatomic, strong) IBOutlet UILabel * _Null_unspecified demoLabel;
/**
  Demo button.  Setting \code
  demoButton
  \endcode.setTitle displays your own title on the screen; otherwise, framework displays the default title.
*/
@property (nonatomic, strong) IBOutlet UIButton * _Null_unspecified demoButton;
/**
  A flag to indicate demo availability.  Default is true.  Only when it’s true, display \code
  Want to explore
  \endcode label and \code
  Try the Demo
  \endcode button.
*/
@property (nonatomic) BOOL isDemoAvailable;
/**
  :nodoc:
*/
- (void)viewDidLoad;
/**
  :nodoc:
*/
- (void)viewWillAppear:(BOOL)animated;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

#pragma clang diagnostic pop
